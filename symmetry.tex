\section{Symmetry reduction}
\label{sec:symmetry}

We now present our use of symmetry reduction.  The techniques of the previous
section produce a potentially infinite set of views, because the types of
component identities are potentially infinite.  However, many such views are
symmetric: one can be obtained from another by uniformly remapping the
parameters.  Our approach is to store a single view from each symmetry
equivalence class.   


Recall that we define a \emph{remapping} to be a partial injective
function~$\pi$ over non-distinguished parameters, that preserves types (for
example, maps each node identity to a node identity, and each thread identity
to a thread identity).  
%
If $\pi$ is a remapping function defined over the parameters of a process
state~$q$, then we write $\pi(q)$ for the effect of replacing each
parameter~$x$ of~$q$ by~$\pi(x)$.  We extend this to sets of states, views,
etc., by pointwise application.  For example, given
%
\begin{eqnarray*}
v & = & 
  \begin{align}
  (\Lock'(T_1), \Head(N_0), \Last(N_1), \Con_3; 
    Enq_4(T_1, N_1, N_3), \Node_y(N_1, Null),\Node_x(N_3, N_1))
  \end{align} \\
\pi & = & 
  \set{ T_1 \mapsto T_0, N_0 \mapsto N_1, N_1 \mapsto N_2, N_3 \mapsto N_0 },
\end{eqnarray*}
%
we have 
\begin{eqnarray*}
\pi(v) & = & 
  \begin{align}
  (\Lock'(T_0), \Head(N_1), \Last(N_2), \Con_3; 
   Enq_4(T_0, N_2, N_0), \Node_y(N_2, Null),\Node_x(N_0, N_2)) .
  \end{align}
\end{eqnarray*}

%%%%%

\begin{definition}
Given two views~$v$ and $v'$, we say that~$v$ and~$v'$ are \emph{equivalent},
written $v \equiv v'$, if there is a remapping~$\pi$ such that $\pi(v) = v'$.
Note that this is an equivalence relation.
\end{definition}

%%%%%

\framebox{Explain} why it's enough to store views, up to equivalence.  As in
previous paper.  I think we want roughly Lemma 20--Lemma 23.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Normal form for views}

We represent each equivalence class of views by a single representative.  More
precisely, we define a normal form of views, and take the representatives to
be the views in normal form: there will be one per equivalence class.  We
describe the normal form below. 

For each type of identities, we assume a linear order over the type.  In
examples below, for node identities we will assume an order $N_0 < N_1 <
N_2 < \ldots$; and similarly for thread identities.  (In the implementation,
identities are represented by non-negative integers: we use the integer
order.)

The following definition captures our normal form.
%
\begin{definition}
Within views, extended views, etc., we use a standard order for the fixed
processes (in the implementation, this order is defined in the input script).
We order components in the order we have been using in examples: principal
first, followed by secondary components in the order corresponding to the
references from the principal (without repetitions).  For extended views, any
additional component is added at the end.  

Given this ordering or processes, we say that a view or extended view is in
\emph{normal form}, if for each type, the first occurrences of each parameter,
when read from left to right, form an initial segment of that type (according
to the linear order described above).

A transition $pre \trans{} post$ is in normal form if $pre$ is in normal form,
the components of~$post$ are in the same order as for~$pre$ (so $post$ itself
might not be in normal form), and the first occurrences of each parameter
within the concatenation of $pre$ and $post$ form an initial segment of that
type.
\end{definition}

For example, the following view is in normal form; we have underlined the
first occurrence of each parameter.
\[
\begin{align}
(\Lock'(\underline{T_0}), \Head(\underline{N_0}), 
    \Last(\underline{N_1}), \Con_3; 
  Enq_4(T_0, N_1, \underline{N_2}), \Node_y(N_1, Null),\Node_x(N_2, N_1)) .
\end{align}
\]

%\framebox{Example} of transition in normal form. 

A view can be reduced to normal form by a simple left-to-right traversal,
keeping track of the remapping built so far, and extending it to map the first
occurrence of each parameter to the first unused parameter of that type.

%% \begin{lemma}
%% \label{lem:normal-form-fixed}
%% If $s$ and~$s'$ are both in normal form, and $\pi(s)$ and~$\pi'(s')$ are
%% substates of the same system state, then $s.\fixed = s'.\fixed$.
%% \end{lemma}
