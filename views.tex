
\section{Choosing the views}

Say that a process state $s$ \emph{references} a component~$cpt$ if
$cpt.id \in c.\params$. 

Given a system state $s = (\fixed, \cpt)$ with $cpt \in \cpt$, let $\cpt'
\subseteq \cpt$ be all components in $\cpt$ that are referenced by $cpt$
(including $cpt$ itself).  We define the corresponding view to be $(\fixed,
\cpt')$.  Write this as $view(s, cpt)$.  Say that $cpt$ is the principal
component of this view.  Given a view~$v$, we write $v.\princ$ for its
principal component.

Example.

%% Given a state $s = (\fixed, \cpt)$, let $\cpt' \subseteq
%% \cpt$ be all components with identity referenced by some server in
%% $\fixed$.  We define a corresponding view to be $(\fixed, \cpt')$.
%% Write this as $srvView(s)$.

Let 
\begin{eqnarray*}
\V & = & 
  \set{view(s, cpt) | s \in \S, cpt \in s.\cpt}. %%  \union 
  %% \set{srvView(s) | s \in \S}.
\end{eqnarray*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Calculating abstract transitions}

The critical thing, then, is, given $V \subseteq \V$, to calculate
\begin{eqnarray*}
aPost(V) & = & \alpha(post(\gamma(V)))
\end{eqnarray*}
efficiently.  It's enough to consider new such views, i.e.~those not in~$V$. 

For the moment, let's consider only active components.  \framebox{Extend} to
active servers.

We are seeking to identify views~$v$ such that
\[
\gamma(V) \ni s \trans{a} s' \sqge_\V v
\]
for some $s$, $s'$, $a$.
%% We begin by describing how to capture the concrete transitions corresponding
%% to the abstract transitions; we then describe how to extract the new
%% views. 

Informally, our approach will be as follows.  We will start with a view $v \in
V$ whose principal component is an active component, and consider the
transitions of that active component.  In some cases we will need to expand
the view to include additional relevant components: either those components
that synchronise on the transition, or to which the principal component
obtains a reference.  We assume that there is at most one such new component.
We will call such an expanded view a \emph{concretization}.  When we expand a
view in this way, we do so only in a way that is compatible with the set $V$
of views.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Previous attempt}

I suspect all of this should be removed.

\framebox{Notation; change below}

%
\begin{definition}
A concretization $c$ is \emph{strongly consistent} with a set $V$ of views if
there exists a  state $s \in \gamma(V)$ such that $c \sqsubseteq s$.
\end{definition}
%
The above definition is not convenient to check algorithmically, so we use a
weaker variant.
%
\begin{definition}
A concretization $c$ is \emph{weakly consistent} with a set $V$ of views if
for each component state $cpt \in c$, there is a view $v \in V$ where $cpt$ is
the principal component, and $v$ and $c$ agree on common processes (i.e.~they
agree on the states of servers and of all components with common identities).
\end{definition}
%
\begin{lemma}
If $c$ is strongly consistent with~$V$, then it is weakly consistent with~$V$.
\end{lemma}
%
\begin{proof}
Suppose $c$ is strongly consistent with~$V$.  So for some $s \in \gamma(V)$ we
have $c \sqsubseteq s$.  Note that we have $\alpha(s) \subseteq V$.  Consider
a component state $cpt \in c$, and let $v = view(s, cpt) \in \alpha(s)$.  Then
$v$ satisfies the conditions required for weak consistency.
\end{proof}
%
This means that we can over-estimate the strongly consistent concretizations
with the weakly consistent ones.  From now on, we say ``consistent'' for
``weakly consistent''.  \framebox{Move this?}

The converse of the above lemma is not true.  Consider a system where the only
reachable states are
\[
(cs_f; cs_1'(T_1), cs_2(T_2), cs_3(T_3,T_1)) \quad\mbox{and}\quad
(cs_f; cs_1(T_1), cs_2'(T_2), cs_3(T_3,T_2)).
\]
Let $V$ be the corresponding set of views (containing six views, three for
each state).  Then the concretization
$c = (cs_f; cs_1(T_1), cs_2(T_2))$ is weakly consistent with~$V$;
but it is not strongly consistent, because no state of $T_3$ can be added
to~$c$ to give a state in~$\gamma(V)$.

\framebox{conjecture} if  every component has a state that references no other
component, then the converse holds -- can extend $c$ to~$s$ by adding in those
component states.  I don't think this is true if a fixed component holds a
reference to one of those absent states.  Add to def of weak consistency that
for every component $id$ referenced by a fixed process, there is a view $v \in
V$ with $id$ as the principal component, and $v$ and $c$ agree on common
processes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{New attempt}

\textbf{Tactic:} Work with example of lock-based stack from the previous
paper.  Consider a few concrete transitions of this model, and how they are
reflected by abstract transitions.  Present the concretizations that the
algorithm considers.  Then show this is adequate.

Each abstract transition will be built from a \emph{view transition}, i.e.~a
transition formed by considering a single view in isolation, as captured by
the following definition.
%
\begin{definition}
We define a \emph{view transition} of view~$v$ to be a transition $v \trans{e}
v'$ such that
%
\begin{itemize}
\item Either $v$ has an active principal with $e$ in its alphabet, or $v$ has
  an active fixed process with $e$ in its alphabet;

\item $v'$ is the same as~$v$ except replacing every (fixed or component)
  process $p$ that has $e$ in its alphabet with a process $p'$ such that $p
  \trans{e} p'$.  (Note that $v'$ might not be a view if the principal
  component gains or loses a reference as a result of the transition; we
  discuss this further below.
\end{itemize}
\end{definition}

The initial views are of the form
\[
\begin{array}{ll}
(Lock, Top(null); Thread(t)) &  \mbox{for $t \in ThreadID$}, \\
(Lock, Top(null); InitNode(n)) & \mbox{for $n \in NodeID$},
\end{array}
\]

Consider a transition where a thread pushing~$x$ performs a $lock$ event.
This can be captured by the transition
%
\begin{eqnarray}
(Lock, Top(null); Push^x_1(t)) & \trans{lock.t} & 
  (Lock'(t), Top(null); Push^x_2(t))
\label{trans:lock}
\end{eqnarray}
%
for $t \in ThreadID$.  Note that each of the pre- and post-states in this
transition is a view, with $t$ as the principal component.  Further, in a
concrete state, no other process would synchronise on the transition.  Hence
this abstract transition can be found by looking just at the transitions of
the processes in the former view.  We call this an \emph{active-component
  transition}: the active component in the transition is the principal
component of the pre- and post-states.


The abstract transition in the previous paragraph was fairly straightforward,
as all the relevant component states were in the initial view.  This might not
always be the case.  Consider a transition where a pushing thread reads a
value $n \ne null$ from $Top$.  This can be partially described by the
transition
\begin{eqnarray*}
(Lock'(t), Top(n); Push_3^x(t)) & \trans{getTop.t.n} &
  (Lock'(t), Top(n); Push_4^x(t, n)).
\end{eqnarray*}
However, the post-state is not a view, as it does not contain the node~$n$
referenced by~$t$.  Instead, we need to extend both states to include this
node, giving transitions such as
%
\begin{equation}
\begin{alignc}
(Lock'(t), Top(n); Push_3^x(t), Node_y(n, n'))  \trans{getTop.t.n} \\
\qquad  (Lock'(t), Top(n); Push_4^x(t, n), Node_y(n, n')).
\end{alignc}
\label{trans:getTop}
\end{equation}
%
We call the above an \emph{extended transition}: we have extended the pre-view
(with~$t$ as the principal component) by adding the component for~$n$.  In the
interests of simplicity, we make the assumption that it is necessary to add at
most one such node, i.e.~the principal component obtains at most one new
reference in each transition.

We can generate such transitions by considering the transitions of the
principal component; then extending the pre-state to add a compatible
state of a component to which the principal component acquires a reference; and
adding the corresponding state of each such component to the post state (here
the added component does not synchronise on the transition so remains in the
same state).  The following definitions describe what we mean by
\emph{compatible}. 
%
\begin{definition}
Given a set of views $V$, we say that two substates~$c$ and~$c'$ are
\emph{compatible} if (1)~$c.\fixed = c'.\fixed$; and (2)~for every
identity~$id$ such that $c.\cpt$ and $c'.\cpt$ both have a component with
identity~$id$, the corresponding component states are equal.
%% ; and (3) the combined substate $(c.\fixed,
%% c.\cpt \union c'.\cpt)$ is consistent with~$V$.
\end{definition}
%
Note that the conditions mean that the combined state  $(c.\fixed,
c.\cpt \union c'.\cpt)$ makes sense.
%

Note that there's a bit of an abstraction here.  We don't check that the whole
of the combined state $(c.\fixed, c.\cpt \union c'.\cpt)$ is compatible
with~$V$: there might be other views of it that aren't in~$V$.


\begin{definition}
Given a set of views $V$, we say that a component state~$cpt$ is
\emph{compatible} with a view~$v$ if there is a view $v' \in V$ that is
compatible with~$v$ and for which $cpt$ is the principal component state.
%
In this case, we define the extension of $v$ with $cpt$ to be $(v.\fixed,
v.\cpt \union \set{cpt})$, i.e.~we add~$cpt$ to~$v$.
\end{definition}
%
In transition~(\ref{trans:getTop}), the state $Node_y(n, n')$ is compatible
with the pre-state, assuming the set~$V$ of views contains a view of the form
$v = (Lock'(t), Top(n); Node_y(n, n'), Node_z(n', n''))$ for some~$z$
and~$n''$.

In other cases, the pre-state might not contain every component that
synchronises on the transition.  In such a case, we extend the pre-state to
add each compatible state of such a component that can perform the relevant
state.  For example, $initNode$ transitions can be captured by extending the
view obtained in transition~(\ref{trans:getTop}), adding the node being
initialised (which must necessarily be in the $InitNode$ state).
\begin{equation}
\begin{alignc}
  (Lock'(t), Top(n); Push_4^x(t, n), Node_y(n, n'), InitNode(n'')) 
    \trans{initNode_x.t.n''.n} \\
\qquad  (Lock'(t), Top(n); Push_5(t, n''), Node_y(n, n'), Node_x(n'', n))
\end{alignc}
\label{trans:initNode}
\end{equation}
The above transition also illustrates that the post-concretization might be
strictly larger than the corresponding view of the principal component: the
thread loses the reference to~$n$ in the transition.  It is straightforward to
remove components that are no longer referenced in order to obtain the
relevant view.  

The transition~(\ref{trans:initNode}) produces a new view for
another component involved in the transition, here the view $(Lock'(t),
Top(n); Node_x(n'', n), Node_y(n, n'))$ of~$n''$.  In this case, the node $n$
to which $n''$ acquires a reference was included in the transition, because
the thread~$t$ had a reference to it in the pre-state.  In all realistic
examples we are aware of, a similar fact is true: a secondary component
obtains a reference only to other components to which the primary component
previously had a reference.  However, if this is not the case, it is necessary
to extend the pre-state by adding each compatible state of the relevant
component.  (\textbf{note} not in prototype?).

%% Another example.  A thread sets the \SCALA{next} reference of a node~$n$ to
%% point to another node~$n'$.  This can be captured by the following
%% transition (where we elide the fixed components). 
%% \[
%% \begin{align}
%% (\ldots; Thread(t, n, n'), Node_x(n, null), Node_y(n', n'')) 
%%   \trans{setNext.t.n.n'} \\
%% \qquad (\ldots; Thread'(t, n, n'), Node_x(n, n'), Node_y(n', n'')).
%% \end{align}
%% \]
%% Note that this transition produces a new view where the node~$n$ is the
%% principal component and has a reference to~$n'$.

So far, we have considered only transitions that produce a view such that the
primary component synchronised on the transition.  However, such a transition
can induce other abstract transitions.  For example the
transition~(\ref{trans:lock}) changes the state of a fixed process, and so
induces corresponding changes in other views; for example, it induces abstract
transitions concerning another thread or a node in its initial state:
%
\begin{eqnarray*}
(Lock, Top(null); Thread(t')) & \trans{lock.t} & 
  (Lock'(t), Top(null); Thread(t')), \\
(Lock, Top(null); InitNode(n)) & \trans{lock.t} & 
  (Lock'(t), Top(null); InitNode(n)),
\end{eqnarray*}
%
for $t' \in ThreadID$ with $t' \ne t$, and for $n \in NodeID$.

%% We say that an abstract transition $pre \trans{e} post$ \emph{induces} another
%% abstract transition $pre' \trans{e} post'$ if $pre$ and $pre'$ are compatible
%% \framebox{define}, $post'.\fixed = post.\fixed$, and for every component that is
%% common between $pre$ and $pre'$, those components have the same states in
%% $post$ and $post'$.   



\begin{definition}
Consider a set of views~$V$, an abstract transition~$pre \trans{e} post$, and
a view $v \in V$ such that $v$ and $pre$ are compatible, but $pre$ does not
contain the principal component of~$v$.  Then the abstract
transition \emph{induces} a new transition $v \trans{e} v'$ where $v'.\fixed =
post.\fixed$, and $v'.\cpts$ is the same as $v.\cpts$ except each component that
changes state in the transition is replaced by the corresponding component
of~$post$. 
\end{definition}

As another example, consider a different datatype (e.g.~a queue) where a
thread~$t$ sets the \SCALA{next} reference of a node~$n$ to point to another
node~$n'$.  This can be captured by a transition such as the following.
\[
\begin{align}
(\fixed; Thread(t, n, n'), Node_x(n, null), Node_y(n', n'')) 
  \trans{setNext.t.n.n'} \\
\qquad (\fixed'; Thread'(t, n, n'), Node_x(n, n'), Node_y(n', n'')).
\end{align}
\]
If some other node (or thread) can have a reference to the node~$n$, this can
induce new transitions, such as the following (assuming the pre-state is
in~$V$). 
\[
\begin{align}
(\fixed; Node_z(n''', n), Node_x(n, null))  \trans{setNext.t.n.n'} \\
\qquad  (\fixed'; Node_z(n''', n), Node_x(n, n')).
\end{align}
\]


\begin{definition}
Given a set $V$ of views, we build the abstract transitions as follows.  For
each $v \in V$, we consider each transition $v \trans{e} v'$ that is possible
for $v.princ$ and any other process in~$v$ that has~$e$ in its alphabet.  We
consider each identity $id$, not matching the identity of a component of~$v$
and such that
%
\begin{itemize}
\item $e$ is in the alphabet of~$id$; or

\item $v.princ$ acquires a reference to~$id$ in the transition
\end{itemize}
%
For each such~$id$, we find all component states~$c$ with identity~$id$ that
are compatible with~$v$.  We form all pre-states $pre$ by extending $v$ with
each such component state~$c$.  We form corresponding post-states $post$ by
extending $v'$ with the corresponding post-states, i.e.\ each state~$c'$ such
that $c \trans{e} c'$ if $e$ is in the alphabet of~$id$; or otherwise the same
states~$c$.  Thus we form extended transitions $pre \trans{e} post$ including
all the relevant component states.

\end{definition}







active/passive principals, and also servers.  This is probably just an
optimisation. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Implementation notes}

To support the above, we need to record the following about transitions.
%
\begin{itemize}
\item
Given a component state $cpt$ and an event~$a$, a function to return the set
of $cpt'$ such that $cpt \trans{a} cpt'$.

\item
Given a state $srvs$ of the servers and an event~$a$, a function to return the
set of~$srv'$ such that $srv \trans{a} srv'$.
\end{itemize}

We also need to store the following about $V$.
\begin{itemize}
\item
Given a concretization $conc \in \gamma(V)$ and a component state~$c$ for a
component identity not in $conc$, test whether $conc \uplus \set{c} \in
\gamma(V)$.  (For constructing the transitions of concretizations.)

\item (For item~\ref{case:view-principal-changes}.) Given a concretization
  $conc \in \gamma(V)$ and a component identity~$id$ not in $conc$, find all
  states~$c$ for~$id$ such that $conc \uplus \set{c} \in \gamma(V)$.  In
  nearly all cases, at least one process in $conc$ will hold the
  reference~$id$.  If a server holds such a reference, iterate over all
  relevant server views to find compatible states.  If a component holds such
  a reference, iterate over all views of that component to find all compatible
  states. 



Given a state $srvs$ of the servers, and states of some of the components
referenced by $srvs$, all compatible states of other such components.

\end{itemize}
