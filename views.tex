
\section{Choosing the views}

We say that a process state $cpt$ \emph{references} a component~$c$ if $c.\id
\in cpt.\params$.  Note that this implies that $c.\id$ is not a distinguished
value.

Consider a system state $(\fixed, \cpt)$, and a particular component $cpt
\in \cpts$.  We write $view((\fixed, \cpt), cpt)$ for the view of the system
state from~$cpt$, i.e.~the fixed processes and all the processes to which
$cpt$ has a reference (including itself):
%
%% Let $\cpts' = \set{c \in \cpts | c.id \in cpt.params}$ be all
%% components in $\cpts$ that are referenced by $cpt$ (including $cpt$ itself).
%% We define the corresponding view to be $(\fixed, \cpt')$.  Write this as
%% $view(s, cpt)$.  
%
\begin{eqnarray*}
view((\fixed, \cpt), cpt) & = &
  (\fixed, \set{c \in \cpts | c.\id \in cpt.\params}).
\end{eqnarray*}
%
We say that $cpt$ is the \emph{principal component} of this view, and the
other components are \emph{secondary components}.  Given a view~$v$, we write
$v.\princ$ for its principal component.  In examples, we will write the
principal as the first component. 

In the example of Figure~\ref{fig:lock-based-queue}, the views will include,
for instance,
\[
\begin{align}
(\Lock'(t), \Head(n_h), \Last(n_l), \Con_3; 
  Enq_4(t, n_l, n), \Node_y(n_l, null),\Node_x(n, n_l)),
\end{align}
\]
for $t \in ThreadID$, $n_h, n_l, n \in NodeID$, and~$x, y \in D$.  Here $t$
has references to~$n_l$ and~$n$, so the two corresponding nodes are included
as secondary components.

Note that if one of the principal's parameters is a distinguished value, then
there is no corresponding component in the view.  For example, the following
would be a valid view, where the thread's second reference is the
distinguished value~$null$ (in fact, no such state is reachable in the
lock-based queue example).
\[
\begin{align}
(\Lock'(t), \Head(n_h), \Last(n_l), \Con_3;   Enq_4(t, null, n), \Node_x(n, n_l)).
\end{align}
\]

%
The initial views are of the form
\[
\begin{array}{ll}
(\Lock, \Head(null), \Last(null), \Con_0; Thread(t)), &
   \mbox{for $t \in ThreadID$}, \\
(\Lock, \Head(null), \Last(null), \Con_0; \InitNode(n)), & 
   \mbox{for $n \in NodeID$}.
\end{array}
\]

We let $\V$ be the set of all views of system states:
%
\begin{eqnarray*}
\V & = & 
  \set{view(s, cpt) | s \in \S, cpt \in s.\cpt}. %%  \union 
  %% \set{srvView(s) | s \in \S}.
\end{eqnarray*}
%
In the following, we use the word ``view'' for a member of~$\V$, and the word
``substate'' (or just ``state'') for a general substate of an element of~$\S$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Calculating abstract transitions}

The critical thing, then, is, given $V \subseteq \V$, to calculate
\begin{eqnarray*}
aPost(V) & = & \alpha(post(\gamma(V)))
\end{eqnarray*}
efficiently.  In fact, we slightly over-estimate $aPost(V)$.

%% We are seeking to identify views~$v$ such that
%% \[
%% \gamma(V) \ni s \trans{a} s' \sqge_\V v
%% \]
%% for some $s$, $s'$, $a$.

In order to motivate our approach, we present example abstract transitions
from the lock-based stack example, and how they can be extracted from
corresponding concrete transitions of components.  We use these examples to
define how we calculate (an over-approximation of) the abstract post-image of
the current set of views.  We then prove that our approach is correct.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Active-process transitions}

We start by considering abstract transitions triggered by an active process
(either an active principal or an active fixed process) within the view.  We
call these \emph{active-process transitions}.

Informally, our approach will be as follows.  We will start with a view $v \in
V$ whose principal component is an active component, and consider the
transitions of that active component.  In some cases we will need to expand
the view to include additional relevant components: either those components
that synchronise on the transition, or to which the principal component
obtains a reference.  We assume that there is at most one such new component.
When we expand a view in this way, we do so only in a way that is compatible
with the set $V$ of views.

\framebox{Active server transitions}

%
Each such transition will be built from a \emph{view transition}, i.e.~a
transition formed by considering a single view in isolation, as captured by
the following definition.
%
\begin{definition}
We define a \emph{view transition} of view~$v$ to be a transition $v \trans{e}
v'$ such that
%
\begin{itemize}
\item Either $v$ has an active principal or an active fixed process with $e$
  in its alphabet;

\item $v'$ is the same as~$v$ except replacing every (fixed or component)
  process~$p$ that has $e$ in its alphabet with a process $p'$ such that \( p
  \trans{e} p' \).  This synchronises all relevant processes on the
  transition. (Note that $v'$ might not be a view if the principal component
  gains or loses a reference as a result of the transition; we discuss this
  further below.)
\end{itemize}
\end{definition}

\impNote{\texttt{system.transitions} generates a representation of the view
  transitions, together with the identity of another process that synchronises
  on the transition (where applicable).}

For example, consider a transition of the lock-based stack where a thread~$t$
pushing~$x$ performs a $lock$ event.  This can be captured view transitions of
the form
%
\begin{equation}
\begin{align}
(\Lock, \Head(n_h), \Last(n_l), \Con_3; Enq^x_1(t))  \trans{lock.t} \\
\qquad  (\Lock'(t), \Head(n_h), \Last(n_l), \Con_3; Enq^x_2(t)) .
\end{align}
\label{trans:lock}
\end{equation}
%
%for $t \in ThreadID$.  
%
In this particular case, the view transition is also an abstract transition.
Each of the pre- and post-states in this transition is a view, with $t$ as the
principal component.  Further, the pre-view contains all components with
$lock.t$ in their alphabet, so in a concrete state, no other process would
synchronise on the transition.

As an example of a transition with an active server, the construction of the
initial dummy header node is described by the following view transition.
\[
\begin{align}
(\Lock, \Head(null), \Last(null), \Con_0; \InitNode(n)) 
  \trans{initNode_{v_0}.C?n.null} \\
\qquad (\Lock, \Head(null), \Last(null), \Con_1(n); \Node_{v_0}(n, null)).
\end{align}
\]
This view transition is again an abstract transition. 

The above two abstract transitions can be found by looking just at the view
transitions of the pre-view.  However, this isn't always the case.

%% The abstract transition in the previous paragraphs was fairly straightforward,
%% as all the relevant component states were in the initial view.  This might not
%% always be the case.  
Consider a transition where a dequeueing thread reads the |next| reference
from the head node.  This can be partially described by the view transition
\[
\begin{align}
(\Lock'(t), \Head(n_h), \Last(n_l), \Con_3; Deq_4(t, n_h), \Node(n_h, n))
  \trans{getNext.t.n_h.n} \\
\qquad (\Lock'(t), \Head(n_h), \Last(n_l), \Con_3; Deq_5(t, n), \Node(n_h, n)).
\end{align}
\]
%% \begin{eqnarray*}
%% (\Lock'(t), Top(n); Push_3^x(t)) & \trans{getTop.t.n} &
%%   (\Lock'(t), Top(n); Push_4^x(t, n)).
%% \end{eqnarray*}
However, the post-state is not a view, as it does not contain the node~$n$
referenced by~$t$, and additionally it does include the node~$n_h$ which is no
longer referenced by~$t$.  To deal with the first point, we need to extend
both states to include this node, giving transitions such as
\begin{equation}
\begin{align}
(\Lock'(t), \Head(n_h), \Last(n_l), \Con_3; 
  Deq_4(t, n_h), \Node(n_h, n), \Node_y(n, n'))  \trans{getNext.t.n_h.n} \\
\qquad (\Lock'(t), \Head(n_h), \Last(n_l), \Con_3; 
  Deq_5(t, n), \Node(n_h, n), \Node_y(n, n')).
\label{trans:getNext}
\end{align}
\end{equation}
%
%% \begin{equation}
%% \begin{alignc}
%% (\Lock'(t), Top(n); Push_3^x(t), Node_y(n, n'))  \trans{getTop.t.n} \\
%% \qquad  (\Lock'(t), Top(n); Push_4^x(t, n), Node_y(n, n')).
%% \end{alignc}
%% \label{trans:getTop}
%% \end{equation}
%
%\framebox{Replace with $getNext$ example?}
%
We call the above an \emph{extended transition}: we have extended the pre-view
by adding the component for~$n$.  In the interests of simplicity, we make the
assumption that it is necessary to add at most one such node, i.e.~the
principal component obtains at most one new reference in each transition.
The above transition also illustrates that the post-state might be strictly
larger than the corresponding view of the principal component: the thread
loses the reference to~$n_h$ in the transition.  It is straightforward to remove
components that are no longer referenced in order to obtain the relevant view.

We can generate extended transitions by considering the view transitions; then
extending the pre-state to add a compatible state of a component to which the
principal component acquires a reference; and adding the corresponding state
of each such component to the post state (here the added component does not
synchronise on the transition so remains in the same state).  The following
definitions describe what we mean by \emph{compatible}.

\impNote{The implementation represents a transition that requires an
  additional component by a \texttt{TransitionTemplate}.}

\begin{definition}
Let $V$ be a set of views.  A component state~$c$ is \emph{strongly
  compatible} with a view~$v \in V$ (with $c.\id$ disjoint from the identities
in~$v$) if there exists a state $s \in \gamma(V)$ such that $v \uplus c \sqle
s$.
\end{definition}
%
The above condition is rather expensive to check, so we weaken it slightly. 
%
\begin{definition}
\label{def:compatible}
Let $V$ be a set of views.  A component state~$c$ is \emph{compatible} with a
view $v \in V$ if:
%
\begin{enumerate}
\item\label{item:compatible-1} $V$ contains a view $v_c$ such that
  (a)~$v_c.\fixed = v.\fixed$, (b)~$v_c.\princ = c$, and (c)~if $c$ has a
  reference to a component of~$v$, then $v$ and~$v_c$ agree on that component.

\item\label{item:compatible-2} If any component $c'$ of~$v$ has a reference
  to~$c$ then $V$ contains a view $v'$ such that (a)~$v'.\fixed = v.\fixed$,
  (b)~$v'.\princ = c'$, and (c)~$v'$ contains $c$.
\end{enumerate}
\end{definition}

In transition~(\ref{trans:getNext}), the state $\Node_y(n, n')$ is compatible
with the pre-view, assuming the set~$V$ of views contains: (1)~a view of the
form $v_c = (\Lock'(t), \Head(n_h), \Last(n_l), \Con_3; \Node_y(n, n'),
\linebreak[1] \Node_z(n', n''))$ for some~$z$ and~$n''$, to satisfy
clause~\ref{item:compatible-1}; and (2) a view of the form $v' = (\Lock'(t),
\Head(n_h), \Last(n_l), \Con_3; \Node(n_h, n), \linebreak[1] \Node_y(n, n')$
to satisfy clause~\ref{item:compatible-2}.

\impNote{This is checked in
  \texttt{Extendability.\linebreak[1]compatible\-With}, with
  \texttt{Extendability.isExtendable} checking the latter clause.}

We show in Section~\ref{sec:views-correctness} that strong compatibility
implies compatibility.  Our implementation uses the weaker definition of
compatibility; this means that we over-estimate the abstract transition
relation, so preserve correctness.  Our experience is that this approximation
does not lead to false positives.

In the transitions we have considered so far, the pre-view contains every
component that synchronises on the transition.  This won't always be true.  In
such a case, we extend the pre-view to add each compatible state of such a
component that can perform the relevant state.  For example, $initNode$
transitions can be captured by extending a view such as 
\[
(\Lock'(t), \Head(n_h), \Last(n_l), \Con_3; Enq_3^x(t, n_l), \Node_y(n_l, n')
\]
adding the node being initialised (which must necessarily be in the $\InitNode$
state).

\begin{equation}
\begin{alignc}
(\Lock'(t), \Head(n_h), \Last(n_l), \Con_3; 
   Enq_3^x(t, n_l), \Node_y(n_l, n'), \InitNode(n))
    \trans{initNode_x.t.n.null} \\
\qquad (\Lock'(t), \Head(n_h), \Last(n_l), \Con_3; 
   Enq_4^x(t, n_l, n), \Node_y(n_l, n'), \Node_x(n, null)).
\end{alignc}
\label{trans:initNode}
\end{equation}
%% \begin{equation}
%% \begin{alignc}
%%   (\Lock'(t), Top(n); Push_4^x(t, n), \Node_y(n, n'), \InitNode(n'')) 
%%     \trans{initNode_x.t.n''.n} \\
%% \qquad  (\Lock'(t), Top(n); Push_5(t, n''), \Node_y(n, n'), \Node_x(n'', n))
%% \end{alignc}
The above transition also illustrates that the post-state might be strictly
larger than the corresponding view of the principal component: the thread
loses the reference to~$n$ in the transition.  It is straightforward to remove
components that are no longer referenced in order to obtain the relevant view.

%% The transition~(\ref{trans:initNode}) produces a new view for
%% another component involved in the transition, here the view $(\Lock'(t),
%% Top(n); Node_x(n'', n), Node_y(n, n'))$ of~$n''$.  In this case, the node $n$
%% to which $n''$ acquires a reference was included in the transition, because
%% the thread~$t$ had a reference to it in the pre-state.  In all realistic
%% examples we are aware of, a similar fact is true: a secondary component
%% obtains a reference only to other components to which the primary component
%% previously had a reference.  Thus our implementation assumes this
%% condition.


The following definition summarises this subsection.
%
\begin{definition}
\label{def:active-process-transition}
Given a set $V$ of views, we build the active-process transitions as follows.
For each $v \in V$, we consider each view transition $v \trans{e} v'$ of~$v$.
We consider each identity $id$, not matching the identity of a component
of~$v$ and such that
%
\begin{itemize}
\item $e$ is in the alphabet of~$id$; or

\item $v.princ$ acquires a reference to~$id$ in the transition
\end{itemize}
%
For each such~$id$ (by assumption, there is at most one), we find all
component states~$c$ with identity~$id$ that are compatible with~$v$
(Definition~\ref{def:compatible}).  We form all pre-states $pre$ by extending
$v$ with each such component state~$c$.  We form corresponding post-states
$post$ by extending $v'$ with the corresponding post-states, i.e.\ each
state~$c'$ such that $c \trans{e} c'$ if $e$ is in the alphabet of~$id$; or
otherwise the same states~$c$.  Thus we form extended transitions $pre
\trans{e} post$ including all the relevant component states.  Finally, we
extract from $post$ the view~$v''$ of the principal component, to create an
abstract transition $v \trans{e} v''$.
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Induced transitions}

So far, we have considered only transitions that produce a view such that the
primary component synchronised on the transition.  \framebox{?} active server
transitions?  However, such a transition can induce other abstract
transitions.  For example the transition~(\ref{trans:lock}) changes the state
of a fixed process, and so induces corresponding changes in other views; for
example, it induces abstract transitions concerning another thread or a node
in its initial state:
%
\[
\begin{align}
(\Lock, \Head(n_h), \Last(n_l), \Con_3; Thread(t'))  \trans{lock.t} \\
\qquad  (\Lock'(t), \Head(n_h), \Last(n_l), \Con_3; Thread(t')), \\
(\Lock,  \Head(n_h), \Last(n_l), \Con_3; \InitNode(n))  \trans{lock.t} \\
\qquad  (\Lock'(t),  \Head(n_h), \Last(n_l), \Con_3; \InitNode(n)),
\end{align}
\]
%
for $t' \in ThreadID$ with $t' \ne t$, and for $n \in NodeID$.

\begin{definition}
\label{def:induced-transition}
Consider an extended transition~$pre \trans{e} post$, and a view $v$ such that
$v$ and $pre$ are accordant.  Then the  transition \emph{induces} a
new transition $v \trans{} v'$ where
\begin{itemize}
\item $v'.\fixed = post.\fixed$;

\item If $v.\princ$ is in $pre$ then $v'.\princ$ is the corresponding
  component in~$post$; otherwise $v'.princ = v.princ$;

\item The secondary components of~$v'$ are the components referenced by
  $v'.princ$, either from $post$ if the component is part of the transition,
  or otherwise from~$v$.  (Note that all such components are included in
  either $post$ or~$v$, by assumption~\ref{assump:secondary-cpts-new-refs}.)
\end{itemize}
\end{definition}

Note that if $pre.princ = v.princ$ then the induced transition is identical to
the original transition.  An obvious optimisation avoids recreating this
transition. 

For example, the  transition~(\ref{trans:initNode}) induces a transition
\[
\begin{align}
(\Lock'(t), \Head(n_h), \Last(n_l), \Con_3; \InitNode(n)) \trans{} \\
\qquad  (\Lock'(t), \Head(n_h), \Last(n_l), \Con_3; \Node_x(n, null)),
\end{align}
\]
where $n''$ evolves as in (\ref{trans:initNode}).

As another example, consider the extended transition where an enqueueing
thread sets the next reference of the last node:
\[
\begin{align}
(\Lock'(t), \Head(n_h), \Last(n_l), \Con_3;  
  Enq_4(t, n_l, n), \Node_y(n_l, null), \Node_x(n, null)) \\
\qquad \trans{setNext.t.n_l.n} \\
\qquad (\Lock'(t), \Head(n_h), \Last(n_l), \Con_3;  
  Enq_5(t, n), \Node_y(n_l, n), \Node_x(n, null)).
\end{align}
\]
This induces the following transition on the view of~$n_l$:
\[
\begin{align}
(\Lock'(t), \Head(n_h), \Last(n_l), \Con_3;  
  \Node_y(n_l, null))
\trans{setNext.t.n_l.n} \\
\qquad (\Lock'(t), \Head(n_h), \Last(n_l), \Con_3;  
  \Node_y(n_l, n), \Node_x(n, null)).
\end{align}
\]


%% As another example, consider a different datatype (e.g.~a queue) where a
%% thread~$t$ sets the \SCALA{next} reference of a node~$n$ to point to another
%% node~$n'$.  This can be captured by a transition such as the following.
%% \[
%% \begin{align}
%% (\fixed; Thread(t, n, n'), \Node_x(n, null), \Node_y(n', n'')) 
%%   \trans{setNext.t.n.n'} \\
%% \qquad (\fixed'; Thread'(t, n, n'), \Node_x(n, n'), \Node_y(n', n'')).
%% \end{align}
%% \]
%% If some other node (or thread) has a reference to the node~$n$, this can
%% induce new transitions, such as the following (assuming the pre-state is
%% in~$V$). 
%% \[
%% \begin{align}
%% (\fixed; \Node_z(n''', n), \Node_x(n, null))  \trans{setNext.t.n.n'} \\
%% \qquad  (\fixed'; \Node_z(n''', n), \Node_x(n, n')).
%% \end{align}
%% \]


%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\subsection{Correctness}
\label{sec:views-correctness}


The following definition summarises how we calculate the abstract transitions.

\begin{definition}
\label{def:abstract-transition}
Given a set $V$ of views, we build each active-process extended transition
$pre \trans{e} post$, and the corresponding abstract transitions $v \trans{e}
v'$, as in Definition~\ref{def:active-process-transition}.
%
We then also create every transition that $pre \trans{e} post$ induces on a
view in~$V$, as in Definition~\ref{def:induced-transition}. 
\end{definition}

We start by comparing the properties of compatibility and strong compatibility.
%
\begin{lemma}
\label{lem:strong-compatible-implies-compatible}
Let $V$ be a set of views.
If a component state~$c$ is strongly compatible with a view~$v \in V$, then
$c$ is compatible with~$v$. 
\end{lemma}
%
\begin{proof}
Suppose $c$ is strongly compatible with~$v$.  Then there exists $s \in
\gamma(V)$ such that $v \uplus c \sqle s$.  Taking $v_c = view(s, c)$
satisfies clause~\ref{item:compatible-1} of Definition~\ref{def:compatible}:
note that $v_c \sqle_\V s \in \gamma(V)$ so $v_c \in V$.  For each component
$c'$ of~$v$ that has a reference to~$c$, taking $v' = view(s,c')$ satisfies
clause~\ref{item:compatible-2}: again $v' \in V$.
\end{proof}

The converse of the above lemma doesn't hold, informally because the views
required for the different constraints of Definition~\ref{def:compatible}
might come from different system states.  More concretely, consider a system
containing just the following system states.
%
\begin{eqnarray*}
s_0 & = &
   (\fixed; Th(t,n_1,n_2), N_A(n_1,n_3), N_B(n_2), N_X(n_3), N_D(n_4,n_3)), \\
s_1 & = &
  (\fixed; Th(t,n_1,n_2), N_X(n_1), N_B(n_2), N_C(n_3,n_2), N_D(n_4,n_1)),\\
s_2 & = & 
  (\fixed; Th(t,n_1,n_2), N_A(n_1,n_3), N_X(n_2), N_C(n_3,n_2), N_D(n_4,n_2)).
\end{eqnarray*}
%
Let $V = \alpha(\set{s_0,s_1,s_2})$ be all views of these states.  Let
\[
v = (\fixed; Th(t,n_1,n_2), N_A(n_1, n_3), N_B(n_2)).
\]
This is a view of the system, resulting from~$s_0$.  Let 
\[
c = N_C(n_3,n_2).
\]  
Then  $c$ is compatible with~$v$.
%
Clause~\ref{item:compatible-1} of Definition~\ref{def:compatible} is satisfied
by $(\fixed; N_C(n_3,n_2), N_B(n_2))$, which is a view resulting
from~$s_1$.
%
And clause~\ref{item:compatible-2} is satisfied for $c' = N_A(n_1,n_3)$ by
$(\fixed; N_A(n_1, n_3), N_C(n_3,n_2))$, which is a view resulting
from~$s_2$. 
%%  And it is satisfied for $c' = N_D(n_4,n_1,n_3)$ by $(\fixed;
%% N_D(n_4,n_1,n_3), N_Y(n_1,n_3),N_C(n_3,n_2)


However $c$ is not strongly compatible with~$v$.  Suppose we have \( v \uplus
c \sqle s \) for some $s \in \gamma(V)$.  Then $s$ is necessarily of the form
\[
\begin{align}
(\fixed, Th(t,n_1,n_2), N_A(n_1, n_3), N_B(n_2), N_C(n_3,n_2), c_4) \\
\qquad \mbox{where $c_4 = N_D(n_4,x)$ for some $x$.}
\end{align}
\]
But no value of~$x$ works: in each case, we have that $view(s, c_4) \nin
\gamma(V)$, since in no system state does $n_4$ have a reference to a
component in state~$N_A$, $N_B$ or~$N_C$.

%% : there is no system state
%% containing $v \uplus c$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lemma}
Let $V$ be a set of views.  Every abstract transition from~$V$ is generated by
the procedure in Definition~\ref{def:abstract-transition}.
\end{lemma}

\begin{proof} 
Consider an abstract transition
\[
\gamma(V) \ni s \trans{e} s' \sqge_{\V} v'.
\]
We need to show that we generate $v'$ as part of the process described above.
Let $pId = v'.\princ.id$ be the identity of the principal of~$v'$, and suppose
that component has states $princ$ and $princ'$ in~$s$ and~$s'$, respectively
(so $v' = view(s', princ')$).  We perform a case analysis.
%
\begin{enumerate}
\item
First suppose $pId$ is the active component in the concrete transition
\( {s \trans{e} s'} \).
Let $v = view(princ, s)$.  
%
Suppose another component is necessary for the transition, as in
Definition~\ref{def:active-process-transition}, i.e.~either another component
synchronises on the transition, or the principal gains a reference, and
suppose that component has state~$c$ in~$s$.  Then $c$ is strongly compatible
with~$v$, since $v \uplus c \sqle s \in \gamma(V)$.  Hence $c$ is compatible
with~$v$, by Lemma~\ref{lem:strong-compatible-implies-compatible}.
%
Let $pre = v \uplus c$, or let $pre = v$ if no additional component is
necessary; and let $post$ be the corresponding states in~$s'$.  Then the
technique of Definition~\ref{def:active-process-transition} builds the
transition \( pre \trans{e} post \).  Finally, the principal's view of $post$
is extracted; this equals~$v'$ by construction, as required. 

%% \item 
%% Now suppose the transition involves an active fixed process, and suppose
%% $princ$ synchronises on the transition.  Let $v = view(princ, s)$.  This case
%% is then  identical to the previous case.

\item
Now suppose the transition $s \trans{e} s'$ has an active component other than
$pId$.  Let $pre \trans{e} post$ be the corresponding extended transition,
built as in Definition~\ref{def:active-process-transition}.  Let $v =
view(princ, s)$.  Then necessarily $v$ and $pre$ are accordant, since they are
both substates of~$s$.  Then the transition $v \trans{} v'$ is induced, as in
Definition~\ref{def:induced-transition}.

\item
Finally suppose the transition $s \trans{e} s'$ has an active fixed process.
Consider an arbitrary corresponding view transition (i.e.~with an arbitrary
principal), and consider the corresponding extended transition $pre \trans{e}
post$.  This case is then identical to the previous case.
\end{enumerate}
\end{proof}


\impNote{The fact that point~3 covers all transitions with active fixed
  processes suggests that we could be more restrictive about generating such
  transitions in Definition~\ref{def:active-process-transition}.}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textbf{Note:} Now consider the changes that have to be made with singleRef,
both for correctness and to avoid false positives. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \subsection{Implementation notes}

%% To support the above, we need to record the following about transitions.
%% %
%% \begin{itemize}
%% \item
%% Given a component state $cpt$ and an event~$a$, a function to return the set
%% of $cpt'$ such that $cpt \trans{a} cpt'$.

%% \item
%% Given a state $srvs$ of the servers and an event~$a$, a function to return the
%% set of~$srv'$ such that $srv \trans{a} srv'$.
%% \end{itemize}

%% We also need to store the following about $V$.
%% \begin{itemize}
%% \item
%% Given a concretization $conc \in \gamma(V)$ and a component state~$c$ for a
%% component identity not in $conc$, test whether $conc \uplus \set{c} \in
%% \gamma(V)$.  (For constructing the transitions of concretizations.)

%% \item (For item~\ref{case:view-principal-changes}.) Given a concretization
%%   $conc \in \gamma(V)$ and a component identity~$id$ not in $conc$, find all
%%   states~$c$ for~$id$ such that $conc \uplus \set{c} \in \gamma(V)$.  In
%%   nearly all cases, at least one process in $conc$ will hold the
%%   reference~$id$.  If a server holds such a reference, iterate over all
%%   relevant server views to find compatible states.  If a component holds such
%%   a reference, iterate over all views of that component to find all compatible
%%   states. 



%% Given a state $srvs$ of the servers, and states of some of the components
%% referenced by $srvs$, all compatible states of other such components.

%% \end{itemize}
