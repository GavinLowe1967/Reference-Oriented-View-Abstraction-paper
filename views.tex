
\section{Choosing the views}

Say that a process state $cs(ps)$ \emph{references} a component~$cpt$ if
$id(cpt) \in ps$. 

Given a state $s = (\srv, \cpt)$ with $cpt \in \cpt$, let $\cpt' \subseteq
\cpt$ be all components in $\cpt$ that are referenced by $cpt$ (including $cpt$
itself).  We define a corresponding view to be $(\srv, \cpt')$.  Write this as
$view(s, cpt)$.  Say that $cpt$ is the principal component of this view. 

Given a state $s = (\srv, \cpt)$, let $\cpt' \subseteq
\cpt$ be all components with identity referenced by some server in
$\srv$.  We define a corresponding view to be $(\srv, \cpt')$.
Write this as $srvView(s)$.

Let 
\begin{eqnarray*}
\V & = & 
  \set{view(s, cpt) | s \in \S, cpt \in s.\cpt} \union 
  \set{srvView(s) | s \in \S}.
\end{eqnarray*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Calculating abstract transitions}

The critical thing, then, is, given $V \subseteq \V$, to calculate
\begin{eqnarray*}
aPost(V) & = & \alpha(post(\gamma(V)))
\end{eqnarray*}
efficiently.  It's enough to consider new such views, i.e.~those not in~$V$. 

For the moment, let's consider only active components.  \framebox{Extend} to
active servers.

We are seeking to identify views~$v$ such that
\[
\gamma(V) \ni s \trans{a} s' \sqge_\V v
\]
for some $s$, $s'$, $a$.
We begin by describing how to capture the concrete transitions corresponding
to the abstract transitions; we then describe how to extract the new views. 

Consider a particular component view $v \in V$ whose principal component is an
active component.  Let $cpt$ be the principal component.  Consider each local
transition from state $cpt$ that is compatible with the remainder of~$v$,
i.e.~each local transition $cpt \trans{a} cpt'$ such that: if $a$ is in the
alphabet of the servers, then $v.\srv \trans{a}$; and similarly, for each
other component~$c$ in~$v.\cpt$, if $a$ is in $c$'s alphabet than $c
\trans{a}$.

Consider the other components (outside~$v$) that synchronise on this
transition (if any).  Suppose the components have identities~$id_1, \ldots,
id_n$ (with $n \ge 0$).  Find all states $c_1, \ldots, c_n$ for those
components that are compatible with~$v$, i.e.\ such that $conc \defs v \uplus
\set{c_1,\ldots,c_n} \in \gamma(V)$.  Then test whether $conc$ can
also perform~$a$ (i.e.~whether each of $c_1,\ldots, c_n$ can).  If so, $conc
\trans{a} conc'$ for some~$conc'$.  The lemma below describes how this
captures relevant concrete transitions.
%%%%%
\begin{lemma}
If \( \gamma(V) \ni s \trans{a} s' \), then the above construction produces a
transition $conc \trans{a} conc'$ where for some set $cpts$ of component
states, $s = conc \uplus cpts$ and $s' = conc' \uplus cpts$.
\end{lemma}
%%%%%
%%%%%
\begin{proof}
Let $cpt$ be the active component in the transition $s \trans{a} s'$.  Take $v
= view(s, cpt)$.  Then the above construction produces a suitable transition
between concretizations, when $conc \sqle s$ is the extension of~$v$ with the
other synchronising components.  The assumption $s \in \gamma(V)$ means that
$conc \in \gamma(V)$.  The set $cpts$ is then just the remaining components
from~$s$, which do not participate in the transition.
\end{proof}

\framebox{The above doesn't get $\tau$s right.}


\textbf{Observation.} In most cases, all the components that synchronise on
the transition will already be in the view~$v$; i.e.~we have $n = 0$ above.
For example, if a thread has a reference to a node~$curr$, and performs $nxt =
curr.next$, this will represent a synchronisation between the thread
and~$curr$, both of which are in the view.  An exception will be where the
thread allocates a new node, which will be a synchronisation between the
thread and a node to which it doesn't previously have a reference.  I can't
think of any case where $n > 1$.

%%%%%

%% \begin{itemize}
%% \item Case each such other component is in $\cpt$.  Then this transition is
%%   available from~$v$.  I.e. $v \trans{a} v'$ for some~$v'$.

%% \item Case there is one other such component, with identity~$id_c$.  Find all
%%   states~$c$ of that component that are compatible with~$v$, i.e.~such that
%%   $\alpha(\srv, \cpt \union \set{c}) \subseteq V$ (equivalently $(\srv, \cpt
%%   \union \set{c}) \in \gamma(V)$).  Let $\hat{v} = (\srv, \cpt \union
%%   \set{c})$.  Then $\hat{v} \trans{a} v'$ for some~$v'$.

%% \item If there are more than one such component, this generalises in the
%%   obvious way.  I think this is quite rare, and we might not support it. 
%% \end{itemize}

For each transition $conc \trans{a} conc'$ produced by the above process, we
then form new views compatible with~$conc'$ and~$V$.  These will include all
new views of the state~$s'$ in the corresponding concrete transition $s
\trans{a} s'$. 
%
\begin{enumerate}
\item \label{case:view-server} We start by considering server views in the
  subsequent state~$s'$.  Note that $conc'.\srv$ might hold references to
  components that are not in $conc$ (or $conc'$).  Suppose those references
  are to components with identities~$id_1, \ldots, id_n$.  Find all states
  $c_1, \ldots, c_n$ for those components that are compatible with~$conc$,
  i.e.~such that $conc_1 \defs conc \uplus \set{c_1,\ldots,c_n} \in
  \gamma(V)$.  Then let $conc_1' \defs conc' \uplus \set{c_1,\ldots,c_n}$.  So
  $conc_1 \trans{a} conc_1'$.  Calculate $srvView(conc_1')$.

\textbf{Alternatively.}  Consider each server view~$v_1$ that matches
$conc.\srv$, and matches the state of each component common with $conc$.
Build the concretization~$conc_1 \defs (conc.\srv, conc.\cpt \union v_1.\cpt)$
Note that $conc'.\srv$ might hold references to components that are not in
$conc_1$ (although this would seem rare).  Suppose those references are to
components with identities~$id_1, \ldots, id_n$.  Find all states $c_1,
\ldots, c_n$ for those components that are compatible with~$conc_1$, i.e.~such
that $conc_2 \defs conc_1 \uplus \set{c_1,\ldots,c_n} \in \gamma(V)$.  Build
$conc_2'$ using $conc'.\srv$, and updating relevant components of $conc_2$
according to the transition.  Then calculate $srvView(conc_2')$.

\item \label{case:view-principal-changes} Consider a component $cpt_1 \in
  conc$ that undergoes the local transition $cpt_1 \trans{a} cpt_1'$ with
  $cpt_1 \ne cpt_1'$.  We construct views for $cpt_1'$ in the subsequent
  state~$s'$.  Suppose $cpt_1'$ holds references to components that are not in
  $conc$ (and $conc'$) with identities~$id_1, \ldots, id_n$.  Find all states
  $c_1, \ldots, c_n$ for those components that are compatible with~$conc$,
  i.e.~such that $conc_1 \defs conc \uplus \set{c_1,\ldots,c_n} \in
  \gamma(V)$.  Then let $conc_1' \defs conc' \uplus \set{c_1,\ldots,c_n}$.  So
  $conc_1 \trans{a} conc_1'$.  Calculate $view(conc_1', cpt_1')$.

\item \label{case:view-principal-present-unchanged} Now consider a component
  $cpt_1 \in conc$ but does not change state in the transition.
  Suppose either the servers change state in the transition, or $cpt_1$ has a
  reference to another component that changes state in the transition.  Find
  every view $v_1 \in V$ for which $cpt_1$ is the principal component, and
  that matches $conc.\srv$ and matches $conc.\cpt$ on all common components.
  Build the view $v_1'$ such that $v_1'.\srv = conc'.\srv$ and $v_1'.\cpt$
  updates $v_1.\cpt$ according to the transition.

\item \label{case:view-nonprincipal-component-changes} Now consider a
  component identity~$id$ that is not in~$conc$, and consider a state $cpt_1$
  of~$id$, that is compatible with~$conc$ (i.e.~$conc \uplus \set{cpt_1} \in
  \gamma(V)$), and that holds a reference to a component that is in~$conc$ and
  undergoes a state change in the transition.  Again, $cpt_1$ might reference
  components that are not in~$conc$.  Find all states $c_1, \ldots, c_n$ for
  those components such that $conc_1 \defs conc \uplus \set{cpt_1, c_1, \ldots,
    c_n} \in \gamma(V)$.  So $conc_1 \trans{a} conc_1' \defs conc' \uplus
  \set{cpt_1, c_1, \ldots, c_n}$.  Build the view $v_1' = view(conc_1',
  cpt_1)$.
  %%  such that $v_1'.\srv = conc'.\srv$, and such that $\v_1'.\cpt$ contains
  %% $\set{cpt_1, c_1, \ldots, c_n}$ and the corresponding component state
  %% from~$conc'.\cpt$


%% So $conc \uplus
%%   \set{cpt_1} \trans{a} conc' \uplus \set{cpt_1}$.  Calculate $view(conc'
%%   \uplus \set{cpt_1}, cpt_1)$.

\item \label{case:view-only-servers-change} Suppose the servers change state
  in the transition: $conc.\srv \ne conc'.\srv$.  Find each component-based
  view $v_1 \in V$ that matches $conc.\srv$, such that the principal component
  is not in~$conc$, and such that each other component of~$v_1$ is either not
  in $conc$ or matches the value in~$conc$ and does not change state in the
  transition.  Build the view $v_1' = (conc'.\srv, v_1.\cpt)$.
\end{enumerate}

%%%%%

\begin{lemma}
Suppose $\gamma(V) \ni s = conc \uplus cpts \trans{a} conc' \uplus cpts = s'
\sqge_\V v'$ with $v' \nin V$ and where the transition $conc \trans{a} conc'$ is
as above.  Then the above construction produces~$v'$.
\end{lemma}

Note: the construction produces more views than just those claimed above. 

\begin{proof}
We perform a case analysis on~$v'$.  Note that the assumption $v' \nin V$
implies that at least one process in~$v'$ changed state as a result of the
transition. 
%
\begin{itemize}
\item Case $v' = srvView(s')$.  Then $v'$ is produced by
  case~\ref{case:view-server}, above, when $c_1,\ldots,c_n$ are the relevant
  component states in~$s$.  \framebox{Alternative case?}

\item Case $v' = view(s', cpt_1')$ where the component~$cpt_1'$ changed state
  from $cpt_1$ in the transition.  Then $v'$ is produced by
  case~\ref{case:view-principal-changes}  when $c_1,\ldots,c_n$ are the
  relevant component states in~$s$.

\item Case $v' = view(s', cpt_1')$ where the component~$cpt_1'$ did not change
  state in the transition, but is in $conc$ (and~$conc'$), and where either
  the servers or one of the other components of~$v'$ did change state.  Then
  $v'$ is captured by case~\ref{case:view-principal-present-unchanged}, where
  $v_1 = view(s, cpt_1') \in V$. 

\item Case $v' = view(s', cpt_1')$ where the component~$cpt_1'$ is not in
  $conc'$, but one of the components referenced by $cpt_1'$ changes state in
  the transition.  Then $v'$ is captured by
  case~\ref{case:view-nonprincipal-component-changes} where $cpt_1 = cpt_1'$
  and $c_1,\ldots,c_n$ are the relevant component states in~$s$.

\item  Case $v' = view(s', cpt_1')$ where the component~$cpt_1'$ is not in
  $conc'$, no component referenced by $cpt_1'$ changes state, but the servers
  do change state.  Then $v'$ is captured by
  case~\ref{case:view-only-servers-change} where $v_1$ is the restriction
  of~$s$ to the relevant components.

\item Case $v' = view(s', cpt_1')$, but no component or server of $v'$ changes
  state during the transition.  Then $v'$ is already in $V$.
\end{itemize}
\end{proof}

%%%%%

\textbf{Question:} Can we narrow some of the cases?


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Implementation notes}

To support the above, we need to record the following about transitions.
%
\begin{itemize}
\item
Given a component state $cpt$ and an event~$a$, a function to return the set
of $cpt'$ such that $cpt \trans{a} cpt'$.

\item
Given a state $srvs$ of the servers and an event~$a$, a function to return the
set of~$srv'$ such that $srv \trans{a} srv'$.
\end{itemize}

We also need to store the following about $V$.
\begin{itemize}
\item
Given a concretization $conc \in \gamma(V)$ and a component state~$c$ for a
component identity not in $conc$, test whether $conc \uplus \set{c} \in
\gamma(V)$.  (For constructing the transitions of concretizations.)

\item (For item~\ref{case:view-principal-changes}.) Given a concretization
  $conc \in \gamma(V)$ and a component identity~$id$ not in $conc$, find all
  states~$c$ for~$id$ such that $conc \uplus \set{c} \in \gamma(V)$.  In
  nearly all cases, at least one process in $conc$ will hold the
  reference~$id$.  If a server holds such a reference, iterate over all
  relevant server views to find compatible states.  If a component holds such
  a reference, iterate over all views of that component to find all compatible
  states. 



Given a state $srvs$ of the servers, and states of some of the components
referenced by $srvs$, all compatible states of other such components.

\end{itemize}
