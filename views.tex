
\section{Choosing the views}

We say that a process state $cpt$ \emph{references} a component~$c$ if
$c.id \in cpt.\params$. 

Consider a system state $(\fixed, \cpt)$, and a particular component $cpt
\in \cpts$.  We write $view((\fixed, \cpt), cpt)$ for the view of the system
state from~$cpt$, i.e.~the fixed processes and all the processes to which
$cpt$ has a reference (including itself):
%
%% Let $\cpts' = \set{c \in \cpts | c.id \in cpt.params}$ be all
%% components in $\cpts$ that are referenced by $cpt$ (including $cpt$ itself).
%% We define the corresponding view to be $(\fixed, \cpt')$.  Write this as
%% $view(s, cpt)$.  
%
\begin{eqnarray*}
view((\fixed, \cpt), cpt) & = &
  (\fixed, \set{c \in \cpts | c.id \in cpt.\params}).
\end{eqnarray*}
%
We say that $cpt$ is the \emph{principal component} of this view, and the
other components are \emph{secondary components}.  Given a view~$v$, we write
$v.\princ$ for its principal component.  In examples, we will write the
principal as the first component. 

In the example of Figure~\ref{fig:lock-based-stack}, the views will include,
for instance,
\[
(Lock'(t), Top(n); Push_4(t, n), Node_x(n, n'))
\]
for $t \in ThreadID$, $n \in NodeID$, $n' \in NodeID \union \set{null}$,
and~$x \in D$.  Here $t$ has a reference to~$n$, so $n$ is included as a
secondary component.
%
The initial views are of the form
\[
\begin{array}{ll}
(Lock, Top(null); Thread(t)) &  \mbox{for $t \in ThreadID$}, \\
(Lock, Top(null); InitNode(n)) & \mbox{for $n \in NodeID$},
\end{array}
\]

We let $\V$ be the set of all views of system states:
%
\begin{eqnarray*}
\V & = & 
  \set{view(s, cpt) | s \in \S, cpt \in s.\cpt}. %%  \union 
  %% \set{srvView(s) | s \in \S}.
\end{eqnarray*}
%
In the following, we use the word ``view'' for a member of~$\V$, and the word
``substate'' (or just ``state'') for a general substate of an element of~$\S$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Calculating abstract transitions}

The critical thing, then, is, given $V \subseteq \V$, to calculate
\begin{eqnarray*}
aPost(V) & = & \alpha(post(\gamma(V)))
\end{eqnarray*}
efficiently.  In fact, we slightly over-estimate $aPost(V)$.

%% We are seeking to identify views~$v$ such that
%% \[
%% \gamma(V) \ni s \trans{a} s' \sqge_\V v
%% \]
%% for some $s$, $s'$, $a$.

In order to motivate our approach, we present example abstract transitions
from the lock-based stack example, and how they can be extracted from
corresponding concrete transitions of components.  We use these examples to
define how we calculate (an over-approximation of) the abstract post-image of
the current set of views.  We then prove that our approach is correct.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Active-process transitions}

We start by considering abstract transitions triggered by an active process
(either an active principal or an active fixed process) within the view.  We
call these \emph{active-process transitions}.

Informally, our approach will be as follows.  We will start with a view $v \in
V$ whose principal component is an active component, and consider the
transitions of that active component.  In some cases we will need to expand
the view to include additional relevant components: either those components
that synchronise on the transition, or to which the principal component
obtains a reference.  We assume that there is at most one such new component.
When we expand a view in this way, we do so only in a way that is compatible
with the set $V$ of views.

\framebox{Active server transitions}

%
Each such transition will be built from a \emph{view transition}, i.e.~a
transition formed by considering a single view in isolation, as captured by
the following definition.
%
\begin{definition}
We define a \emph{view transition} of view~$v$ to be a transition $v \trans{e}
v'$ such that
%
\begin{itemize}
\item Either $v$ has an active principal or an active fixed process with $e$
  in its alphabet;

\item $v'$ is the same as~$v$ except replacing every (fixed or component)
  process~$p$ that has $e$ in its alphabet with a process $p'$ such that \( p
  \trans{e} p' \).  This synchronises all relevant processes on the
  transition. (Note that $v'$ might not be a view if the principal component
  gains or loses a reference as a result of the transition; we discuss this
  further below.)
\end{itemize}
\end{definition}

\impNote{\texttt{system.transitions} generates a representation of the view
  transitions, together with the identity of another process that synchronises
  on the transition (where applicable).}

For example, consider a transition of the lock-based stack where a thread
pushing~$x$ performs a $lock$ event.  This can be captured by the view
transition
%
\begin{eqnarray}
(Lock, Top(null); Push^x_1(t)) & \trans{lock.t} & 
  (Lock'(t), Top(null); Push^x_2(t))
\label{trans:lock}
\end{eqnarray}
%
for $t \in ThreadID$.  
%
In this particular case, the view transition is also an abstract transition.
Each of the pre- and post-states in this transition is a view, with $t$ as the
principal component.  Further, the pre-view contains all components with
$lock.t$ in their alphabet, so in a concrete state, no other process would
synchronise on the transition.  Hence this abstract transition can be found by
looking just at the view transitions of the pre-view.  However, this isn't
always the case.

%% The abstract transition in the previous paragraphs was fairly straightforward,
%% as all the relevant component states were in the initial view.  This might not
%% always be the case.  
Consider a transition where a pushing thread reads a
value $n \ne null$ from $Top$.  This can be partially described by the
view transition
\begin{eqnarray*}
(Lock'(t), Top(n); Push_3^x(t)) & \trans{getTop.t.n} &
  (Lock'(t), Top(n); Push_4^x(t, n)).
\end{eqnarray*}
However, the post-state is not a view, as it does not contain the node~$n$
referenced by~$t$.  Instead, we need to extend both states to include this
node, giving transitions such as
%
\begin{equation}
\begin{alignc}
(Lock'(t), Top(n); Push_3^x(t), Node_y(n, n'))  \trans{getTop.t.n} \\
\qquad  (Lock'(t), Top(n); Push_4^x(t, n), Node_y(n, n')).
\end{alignc}
\label{trans:getTop}
\end{equation}
%
We call the above an \emph{extended transition}: we have extended the pre-view
by adding the component for~$n$.  In the interests of simplicity, we make the
assumption that it is necessary to add at most one such node, i.e.~the
principal component obtains at most one new reference in each transition.

We can generate such transitions by considering the view transitions; then
extending the pre-state to add a compatible state of a component to which the
principal component acquires a reference; and adding the corresponding state
of each such component to the post state (here the added component does not
synchronise on the transition so remains in the same state).  The following
definitions describe what we mean by \emph{compatible}.

\impNote{The implementation represents a transition that requires an
  additional component by a \texttt{TransitionTemplate}.}

\begin{definition}
Let $V$ be a set of views.  A component state~$c$ is \emph{strongly
  compatible} with a view~$v \in V$ (with $c.\id$ disjoint from the identities
in~$v$) if there exists a state $s \in \gamma(V)$ such that $v \uplus c \sqle
s$.
\end{definition}

%% \begin{itemize}
%% \item An extended view~$v$ is \emph{strongly consistent} if there exists a
%%   state $s \in \gamma(V)$ such that $v \sqle s$. \framebox{Needed?}

%% \item A component state~$c$ is \emph{strongly compatible} with a view~$v \in
%%   V$ (with $c.\id$ disjoint from the identities in~$v$) if $v \uplus c$ is
%%   strongly consistent.
%% \end{itemize}

The above condition is rather expensive to check, so we weaken it slightly. 
%
\begin{definition}
\label{def:compatible}
Let $V$ be a set of views.  A component state~$c$ is \emph{compatible} with a
view $v \in V$ if:
%
\begin{enumerate}
\item\label{item:compatible-1} $V$ contains a view $v_c$ such that
  (a)~$v_c.\fixed = v.\fixed$, (b)~$v_c.\princ = c$, and (c)~if $c$ has a
  reference to a component of~$v$, then $v$ and~$v_c$ agree on that component.

\item\label{item:compatible-2} If any component $c'$ of~$v$ has a reference
  to~$c$ then $V$ contains a view $v'$ such that (a)~$v'.\fixed = v.\fixed$,
  (b)~$v'.\princ = c'$, and (c)~$v'$ contains $c$.
\end{enumerate}
\end{definition}

In transition~(\ref{trans:getTop}), the state $Node_y(n, n')$ is compatible
with the pre-view, assuming the set~$V$ of views contains a view of the form
$v_c = (Lock'(t), Top(n); Node_y(n, n'), Node_z(n', n''))$ for some~$z$
and~$n''$, to satisfy clause~\ref{item:compatible-1}
(clause~\ref{item:compatible-2} is satisfied vacuously).

\impNote{This is checked in
  \texttt{Extendability.\linebreak[1]compatible\-With}, with
  \texttt{Extendability.isExtendable} checking the latter clause.}

We show in Section~\ref{sec:views-correctness} that strong compatibility
implies compatibility.  Our implementation uses the weaker definition of
compatibility; this means that we over-estimate the abstract transition
relation, so preserve correctness.  Our experience is that this approximation
does not lead to false positives.

In the transitions we have considered so far, the pre-view contains every
component that synchronises on the transition.  This won't always be true.  In
such a case, we extend the pre-view to add each compatible state of such a
component that can perform the relevant state.  For example, $initNode$
transitions can be captured by extending the view obtained in
transition~(\ref{trans:getTop}), adding the node being initialised (which must
necessarily be in the $InitNode$ state).
\begin{equation}
\begin{alignc}
  (Lock'(t), Top(n); Push_4^x(t, n), Node_y(n, n'), InitNode(n'')) 
    \trans{initNode_x.t.n''.n} \\
\qquad  (Lock'(t), Top(n); Push_5(t, n''), Node_y(n, n'), Node_x(n'', n))
\end{alignc}
\label{trans:initNode}
\end{equation}
The above transition also illustrates that the post-state might be strictly
larger than the corresponding view of the principal component: the thread
loses the reference to~$n$ in the transition.  It is straightforward to remove
components that are no longer referenced in order to obtain the relevant view.

%% The transition~(\ref{trans:initNode}) produces a new view for
%% another component involved in the transition, here the view $(Lock'(t),
%% Top(n); Node_x(n'', n), Node_y(n, n'))$ of~$n''$.  In this case, the node $n$
%% to which $n''$ acquires a reference was included in the transition, because
%% the thread~$t$ had a reference to it in the pre-state.  In all realistic
%% examples we are aware of, a similar fact is true: a secondary component
%% obtains a reference only to other components to which the primary component
%% previously had a reference.  Thus our implementation assumes this
%% condition.


The following definition summarises this subsection.
%
\begin{definition}
\label{def:active-process-transition}
Given a set $V$ of views, we build the active-process transitions as follows.
For each $v \in V$, we consider each view transition $v \trans{e} v'$ of~$v$.
We consider each identity $id$, not matching the identity of a component
of~$v$ and such that
%
\begin{itemize}
\item $e$ is in the alphabet of~$id$; or

\item $v.princ$ acquires a reference to~$id$ in the transition
\end{itemize}
%
For each such~$id$ (by assumption, there is at most one), we find all
component states~$c$ with identity~$id$ that are compatible with~$v$
(Definition~\ref{def:compatible}).  We form all pre-states $pre$ by extending
$v$ with each such component state~$c$.  We form corresponding post-states
$post$ by extending $v'$ with the corresponding post-states, i.e.\ each
state~$c'$ such that $c \trans{e} c'$ if $e$ is in the alphabet of~$id$; or
otherwise the same states~$c$.  Thus we form extended transitions $pre
\trans{e} post$ including all the relevant component states.  Finally, we
extract from $post$ the view~$v'$ of the principal component, to create an
abstract transition $v \trans{e} v'$.
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Induced transitions}

So far, we have considered only transitions that produce a view such that the
primary component synchronised on the transition.  \framebox{?} active server
transitions?  However, such a transition can induce other abstract
transitions.  For example the transition~(\ref{trans:lock}) changes the state
of a fixed process, and so induces corresponding changes in other views; for
example, it induces abstract transitions concerning another thread or a node
in its initial state:
%
\begin{eqnarray*}
(Lock, Top(null); Thread(t')) & \trans{lock.t} & 
  (Lock'(t), Top(null); Thread(t')), \\
(Lock, Top(null); InitNode(n)) & \trans{lock.t} & 
  (Lock'(t), Top(null); InitNode(n)),
\end{eqnarray*}
%
for $t' \in ThreadID$ with $t' \ne t$, and for $n \in NodeID$.

\begin{definition}
\label{def:induced-transition}
Consider an extended transition~$pre \trans{e} post$, and a view $v$ such that
$v$ and $pre$ are accordant.  Then the abstract transition \emph{induces} a
new transition $v \trans{} v'$ where
\begin{itemize}
\item $v'.\fixed = post.\fixed$;

\item If $v.\princ$ is in $pre$ then $v'.\princ$ is the corresponding
  component in~$post$; otherwise $v'.princ = v.princ$;

\item The secondary components of~$v'$ are the components referenced by
  $v'.princ$, either from $post$ if the component is part of the transition,
  or otherwise from~$v$.
\end{itemize}
\end{definition}

Note that if $pre.princ = v.princ$ then the induced transition is identical to
the original transition.  An obvious optimisation avoids recreating this
transition. 

For example, the  transition~(\ref{trans:initNode}) induces a transition
\[
\begin{align}
(Lock'(t), Top(n); InitNode(n'')) \trans{} \\
\qquad  (Lock'(t), Top(n); Node_x(n'', n), Node_y(n, n')),
\end{align}
\]
where $n''$ evolves as in (\ref{trans:initNode}), and acquires a reference
to~$n$. 

As another example, consider a different datatype (e.g.~a queue) where a
thread~$t$ sets the \SCALA{next} reference of a node~$n$ to point to another
node~$n'$.  This can be captured by a transition such as the following.
\[
\begin{align}
(\fixed; Thread(t, n, n'), Node_x(n, null), Node_y(n', n'')) 
  \trans{setNext.t.n.n'} \\
\qquad (\fixed'; Thread'(t, n, n'), Node_x(n, n'), Node_y(n', n'')).
\end{align}
\]
If some other node (or thread) has a reference to the node~$n$, this can
induce new transitions, such as the following (assuming the pre-state is
in~$V$). 
\[
\begin{align}
(\fixed; Node_z(n''', n), Node_x(n, null))  \trans{setNext.t.n.n'} \\
\qquad  (\fixed'; Node_z(n''', n), Node_x(n, n')).
\end{align}
\]


%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\subsection{Correctness}
\label{sec:views-correctness}


The following definition summarises how we calculate the abstract transitions.

\begin{definition}
Given a set $V$ of views, we build each active-process extended transition
$pre \trans{e} post$, and the corresponding abstract transitions $v \trans{e}
v'$, as in Definition~\ref{def:active-process-transition}.
%
We then also create every transition that $pre \trans{e} post$ induces on a
view in~$V$. 
\end{definition}

We start by comparing the properties of compatibility and strong compatibility.
%
\begin{lemma}
\label{lem:strong-compatible-implies-compatible}
If a component state~$c$ is strongly compatible with a view~$v$, then
$c$ is compatible with~$v$. 
\end{lemma}
%
\begin{proof}
Suppose $c$ is strongly compatible with~$v$.  Then there exists $s \in
\gamma(V)$ such that $v \uplus c \sqle s$.  Taking $v_c = view(s, c)$
satisfies clause~\ref{item:compatible-1} of Definition~\ref{def:compatible}:
note that $v_c \sqle_\V s$ so $v_c \in V$.  For each component $c'$ of~$v$
that has a reference to~$c$, taking $v' = view(s,c')$ satisfies
clause~\ref{item:compatible-2}: again $v' \in V$.
\end{proof}

The converse of the above lemma doesn't hold, informally because the views
required for the different constraints of Definition~\ref{def:compatible}
might come from different system states.  More concretely, consider a system
containing just the following system states.
%
\begin{eqnarray*}
s_0 & = &
   (\fixed; Th(t,n_1,n_2), N_A(n_1,n_3), N_B(n_2), N_X(n_3), N_D(n_4,n_3)), \\
s_1 & = &
  (\fixed; Th(t,n_1,n_2), N_X(n_1), N_B(n_2), N_C(n_3,n_2), N_D(n_4,n_1)),\\
s_2 & = & 
  (\fixed; Th(t,n_1,n_2), N_A(n_1,n_3), N_X(n_2), N_C(n_3,n_2), N_D(n_4,n_2)).
\end{eqnarray*}
%
Let $V = \alpha(\set{s_0,s_1,s_2})$ be all views of these states.  Let
\[
v = (\fixed; Th(t,n_1,n_2), N_A(n_1, n_3), N_B(n_2)).
\]
This is a view of the system, resulting from~$s_0$.  Let 
\[
c = N_C(n_3,n_2).
\]  
Then  $c$ is compatible with~$v$.
%
Clause~\ref{item:compatible-1} of Definition~\ref{def:compatible} is satisfied
by $(\fixed; N_C(n_3,n_2), N_B(n_2))$, which is a view resulting
from~$s_1$.
%
And clause~\ref{item:compatible-2} is satisfied for $c' = N_A(n_1,n_3)$ by
$(\fixed; N_A(n_1, n_3), N_C(n_3,n_2))$, which is a view resulting
from~$s_2$. 
%%  And it is satisfied for $c' = N_D(n_4,n_1,n_3)$ by $(\fixed;
%% N_D(n_4,n_1,n_3), N_Y(n_1,n_3),N_C(n_3,n_2)


However $c$ is not strongly compatible with~$v$.  Suppose we have \( v \uplus
c \sqle s \) for some $s \in \gamma(V)$.  Then $s$ is necessarily of the form
\[
\begin{align}
(\fixed, Th(t,n_1,n_2), N_A(n_1, n_3), N_B(n_2), N_C(n_3,n_2), c_4) \\
\qquad \mbox{where $c_4 = N_D(n_4,x)$ for some $x$.}
\end{align}
\]
But no value of~$x$ works: in each case, we have that $view(s, c_4) \nin
\gamma(V)$, since in no system state does $n_4$ have a reference to a
component in state~$N_A$, $N_B$ or~$N_C$.

%% : there is no system state
%% containing $v \uplus c$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lemma}
Every abstract transition from~$V$ is generated by the above procedure.
\end{lemma}

\begin{proof} 
Consider an abstract transition
\[
\gamma(V) \ni s \trans{e} s' \sqge_{\V} v'.
\]
We need to show that we generate $v'$ as part of the process described above.
Let  $princ = v'.\princ$.
We perform a case analysis.
%
\begin{enumerate}
\item
Suppose $princ$ is the active component in the concrete transition
\( {s \trans{e} s'} \).
Let $v = view(princ, s)$.  
%
Suppose another component is necessary for the transition, as in
Definition~\ref{def:active-process-transition}, i.e.~either another component
synchronises on the transition, or the principal gains a reference, and
suppose that component has state~$c$ in~$s$.  Then $c$ is strongly compatible
with~$v$, since $v \uplus c \sqle s \in \gamma(V)$.  Hence $c$ is compatible
with~$v$, by Lemma~\ref{lem:strong-compatible-implies-compatible}.
%
Let $pre = v \uplus c$, or let $pre = v$ if no additional component is
necessary; and let $post$ be the corresponding states in~$s'$.  Then the
technique of Definition~\ref{def:active-process-transition} builds the
transition \( pre \trans{e} post \).  Finally, the principal's view of $post$
is extracted; this equals~$v'$ by construction, as required. 

%% \item 
%% Now suppose the transition involves an active fixed process, and suppose
%% $princ$ synchronises on the transition.  Let $v = view(princ, s)$.  This case
%% is then  identical to the previous case.

\item
Now suppose the transition has an active component other than princ.  Let $pre
\trans{e} post$ be the corresponding extended transition, built as in
Definition~\ref{def:active-process-transition}.  Let $v = view(princ, s)$.
Then necessarily $v$ and $pre$ are accordant, since they are both substates
of~$s$.  Then the transition $v \trans{} v'$ is induced, as in
Definition~\ref{def:induced-transition}.

\item
Finally suppose the transition has an active fixed process.  Consider an
arbitrary corresponding view transition, and the corresponding extended
transition $pre \trans{e} post$.  This case is then identical to the previous
case.
\end{enumerate}
\end{proof}


\impNote{The fact that point~3 covers all transitions with active fixed
  processes suggests that we could be more restrictive about generating such
  transitions in Definition~\ref{def:active-process-transition}.}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textbf{Note:} Now consider the changes that have to be made with singleRef,
both for correctness and to avoid false positives. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \subsection{Implementation notes}

%% To support the above, we need to record the following about transitions.
%% %
%% \begin{itemize}
%% \item
%% Given a component state $cpt$ and an event~$a$, a function to return the set
%% of $cpt'$ such that $cpt \trans{a} cpt'$.

%% \item
%% Given a state $srvs$ of the servers and an event~$a$, a function to return the
%% set of~$srv'$ such that $srv \trans{a} srv'$.
%% \end{itemize}

%% We also need to store the following about $V$.
%% \begin{itemize}
%% \item
%% Given a concretization $conc \in \gamma(V)$ and a component state~$c$ for a
%% component identity not in $conc$, test whether $conc \uplus \set{c} \in
%% \gamma(V)$.  (For constructing the transitions of concretizations.)

%% \item (For item~\ref{case:view-principal-changes}.) Given a concretization
%%   $conc \in \gamma(V)$ and a component identity~$id$ not in $conc$, find all
%%   states~$c$ for~$id$ such that $conc \uplus \set{c} \in \gamma(V)$.  In
%%   nearly all cases, at least one process in $conc$ will hold the
%%   reference~$id$.  If a server holds such a reference, iterate over all
%%   relevant server views to find compatible states.  If a component holds such
%%   a reference, iterate over all views of that component to find all compatible
%%   states. 



%% Given a state $srvs$ of the servers, and states of some of the components
%% referenced by $srvs$, all compatible states of other such components.

%% \end{itemize}
