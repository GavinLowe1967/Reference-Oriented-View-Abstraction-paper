
\section{Choosing the views}

We say that a process state $cpt$ \emph{references} a component~$c$ if $c.\id
\in cpt.\params$.  Note that $c.\id$ is not a distinguished value.

Consider a system state $s$, and a particular component $cpt \in s.\cpts$.  We
write $view(s, cpt)$ for the view of the system state from~$cpt$, i.e.~the
fixed processes of~$s$, and all the components of~$s$ to which $cpt$ has a
reference (including itself):
%
%% Let $\cpts' = \set{c \in \cpts | c.id \in cpt.params}$ be all
%% components in $\cpts$ that are referenced by $cpt$ (including $cpt$ itself).
%% We define the corresponding view to be $(\fixed, \cpt')$.  Write this as
%% $view(s, cpt)$.  
%
\begin{eqnarray*}
view(s, cpt) & = &
  (s.\fixed, \set{c \in s.\cpts \| c.\id \in cpt.\params}).
\end{eqnarray*}
%
We say that $cpt$ is the \emph{principal component} of this view, and the
other components are \emph{secondary components}.  Given a view~$v$, we write
$v.\princ$ for its principal component. 

In examples, we will write views by listing their fixed components in some
standard order, then listing the components with the principal first, and then
following the order of the references in the principal's parameters.  For
instance, in the example of Figure~\ref{fig:lock-based-queue}, the views will
include,
\[
\begin{align}
(\Lock'(t), \Head(n_h), \Last(n_l), \Con_3; 
  Enq_4(t, n_l, n), \Node_y(n_l, null),\Node_x(n, n_l)),
\end{align}
\]
for $t \in ThreadID$, $n_h, n_l, n \in NodeID$, and~$x, y \in D$.  Here the
principal~$t$ has references to~$n_l$ and~$n$, so the two corresponding nodes
are included as secondary components.

The initial views are of the form
\[
\begin{array}{ll}
(\Lock, \Head(null), \Last(null), \Con_0; Thread(t)), &
   \mbox{for $t \in ThreadID$}, \\
(\Lock, \Head(null), \Last(null), \Con_0; \InitNode(n)), & 
   \mbox{for $n \in NodeID$}.
\end{array}
\]

For examples based on Figure~\ref{fig:lock-based-queue}, in the interests of
conciseness, we define
\begin{eqnarray*}
fixed(t, n_h, n_l) & = & (\Lock'(t), \Head(n_h), \Last(n_l), \Con_3), \\
fixed(\_, n_h, n_l) & = & (\Lock, \Head(n_h), \Last(n_l), \Con_3).
\end{eqnarray*}
%
These are fixed processes where the constructor has completed, the head and
last nodes are $n_h$ and~$n_l$, and, respectively, the lock is held by~$t$ or
not held. 

Note that if one of the principal's parameters is a distinguished value, then
there is no corresponding component in the view.  For example, the following
would be a valid view, where the thread's second reference is the
distinguished value~$null$ (in fact, no such state is reachable in the
lock-based queue example).
\[\it
(fixed(t, n_h, n_l);   Enq_4(t, null, n), \Node_x(n, n_l)).
\]


We let $\V$ be the set of all views of system states:
%
\begin{eqnarray*}
\V & = & 
  \set{view(s, cpt) \| s \in \S, cpt \in s.\cpt}. %%  \union 
  %% \set{srvView(s) | s \in \S}.
\end{eqnarray*}
%
In the following, we use the word ``view'' for a member of~$\V$, and the word
``substate'' (or just ``state'') for a general substate of an element of~$\S$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Calculating abstract transitions}

The critical thing, then, is, given $V \subseteq \V$, to calculate
\begin{eqnarray*}
aPost(V) & = & \alpha(post(\gamma(V)))
\end{eqnarray*}
efficiently.  In fact, we slightly over-estimate $aPost(V)$.

%% We are seeking to identify views~$v$ such that
%% \[
%% \gamma(V) \ni s \trans{a} s' \sqge_\V v
%% \]
%% for some $s$, $s'$, $a$.

In order to motivate our approach, we present example abstract transitions
from the lock-based queue example, and how they can be extracted from
corresponding concrete transitions of components.  We use these examples to
define how we calculate (an over-approximation of) the abstract post-image of
the current set of views.  We then prove that our approach is correct.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Active-process transitions}

We start by considering abstract transitions triggered by an active process
(either an active principal or an active fixed process) within the view.  We
call these \emph{active-process transitions}.

Informally, our approach will be as follows.  We will start with a view $v \in
V$, and consider transitions involving either an active principal or active
fixed process synchronising on the transition.
%% ; (1)~of the principal, if it is an active component; (2)~of any active
%% fixed process, either synchronising with the principal or no component.
In some cases we will need to expand
the view to include additional relevant components: either those components
that synchronise on the transition, or to which the principal component
obtains a reference.  We assume that there is at most one such new component.
When we expand a view in this way, we do so only in a way that is compatible
with the set $V$ of views.

Each such transition will be built from a \emph{view transition}, i.e.~a
transition formed by considering a single view in isolation, as captured by
the following definition.
%
\begin{definition}
We define a \emph{view transition} of view~$v$ to be a transition $v \trans{e}
v'$ such that
%
\begin{itemize}
\item $v$ has either an active principal or an active fixed process with $e$
  in its alphabet.
%, and either the
%  principal or no component has $e$ in its alphabet.

\item $v'$ is the same as~$v$ except replacing every (fixed or component)
  process~$p$ that has $e$ in its alphabet with a process $p'$ such that \( p
  \trans{e} p' \).  This synchronises all relevant processes on the
  transition. (Note that $v'$ might not be a view if the principal component
  gains or loses a reference as a result of the transition; we discuss this
  further below.)
\end{itemize}
\end{definition}

\begin{impNote}
\texttt{system.transitions} generates a representation of the view
  transitions, together with the identity of another process that synchronises
  on the transition (where applicable).
\end{impNote}

For example, consider a transition of the lock-based queue where a thread~$t$
pushing~$x$ performs a $lock$ event.  This can be captured by view transitions
of the form
%
\begin{equation}\it
(fixed(\_, n_h, n_l); Enq^x_1(t))  \trans{lock.t}
  (fixed(t, n_h, n_l); Enq^x_2(t)) .
\label{trans:lock}
\end{equation}
%
%for $t \in ThreadID$.  
%
In this particular case, the view transition is also an abstract transition.
Each of the pre- and post-states in this transition is a view, with $t$ as the
principal component.  Further, the pre-view contains all components with
$lock.t$ in their alphabet (just the principal), so in a concrete state, no
other process would synchronise on the transition.

As an example of a transition with an active fixed process, the construction
of the initial dummy header node is described by the following view
transition.
\[
\begin{align}
(\Lock, \Head(null), \Last(null), \Con_0; \InitNode(n)) 
  \trans{initNode_{v_0}.C?n.null} \\
\qquad (\Lock, \Head(null), \Last(null), \Con_1(n); \Node_{v_0}(n, null)).
\end{align}
\]
Here the only component that synchronises on the transition is the principal.
This view transition is again an abstract transition.

The above two abstract transitions can be found by looking just at the view
transitions of the pre-view.  However, this isn't always the case.

%% The abstract transition in the previous paragraphs was fairly straightforward,
%% as all the relevant component states were in the initial view.  This might not
%% always be the case.  
Consider a transition where a dequeueing thread reads the $next$ reference
from the head node.  This can be partially described by the view transition
\[
\begin{align}
(fixed(t, n_h, n_l); Deq_4(t, n_h), \Node(n_h, n))
  \trans{getNext.t.n_h.n} \\
\qquad (fixed(t, n_h, n_l); Deq_5(t, n), \Node(n_h, n)).
\end{align}
\]
%% \begin{eqnarray*}
%% (\Lock'(t), Top(n); Push_3^x(t)) & \trans{getTop.t.n} &
%%   (\Lock'(t), Top(n); Push_4^x(t, n)).
%% \end{eqnarray*}
However, the post-state is not a view, as it does not contain the node~$n$
referenced by~$t$, and additionally it does include the node~$n_h$ which is no
longer referenced by~$t$.  To deal with the first point, we need to extend
both states to include this node, giving transitions such as
\begin{equation}
\begin{align}
(fixed(t, n_h, n_l); Deq_4(t, n_h), \Node(n_h, n), \Node_y(n, n'))
  \trans{getNext.t.n_h.n} \\
\qquad (fixed(t, n_h, n_l);   Deq_5(t, n), \Node(n_h, n), \Node_y(n, n')).
\label{trans:getNext}
\end{align}
\end{equation}
%
%% \begin{equation}
%% \begin{alignc}
%% (\Lock'(t), Top(n); Push_3^x(t), Node_y(n, n'))  \trans{getTop.t.n} \\
%% \qquad  (\Lock'(t), Top(n); Push_4^x(t, n), Node_y(n, n')).
%% \end{alignc}
%% \label{trans:getTop}
%% \end{equation}
%
%\framebox{Replace with $getNext$ example?}
%
We call the above an \emph{extended transition}: we have extended the pre-view
by adding the component for~$n$.  In the interests of simplicity, we make the
assumption that it is necessary to add at most one such node, i.e.~the
principal component obtains at most one new reference in each transition.
The above transition also illustrates that the post-state might be strictly
larger than the corresponding view of the principal component: the thread
loses the reference to~$n_h$ in the transition.  It is straightforward to remove
components that are no longer referenced in order to obtain the relevant view.

We can generate extended transitions by considering the view transitions; then
extending the pre-state to add a compatible state of a component to which the
principal component acquires a reference; and adding the corresponding state
of each such component to the post state (here the added component does not
synchronise on the transition so remains in the same state).  The following
definitions describe what we mean by \emph{compatible}.

\begin{impNote}
The implementation represents a transition that requires an
  additional component by a \texttt{TransitionTemplate}.
\end{impNote}

\begin{definition}
Let $V$ be a set of views.  A component state~$c$ is \emph{consistent} with a
view~$v \in V$ (with $c.\id$ disjoint from the identities in~$v$) if there
exists a state $s \in \gamma(V)$ such that $v \uplus c \sqle s$.
\end{definition}
%
The above condition is rather expensive to check, so we weaken it slightly. 
%
\begin{definition}
\label{def:compatible}
Let $V$ be a set of views.  A component state~$c$ is \emph{compatible} with a
view $v \in V$ if:
%
\begin{enumerate}
\item\label{item:compatible-1} $V$ contains a view $v_c$ such that $v_c.\princ
  = c$, and $v$ and~$v_c$ are accordant.

%% (a)~$v_c.\fixed = v.\fixed$, (b)~$v_c.\princ = c$, and (c)~if $c$ has a
%% reference to a component of~$v$, then $v$ and~$v_c$ agree on that
%% component.

\item\label{item:compatible-2} If any component $c'$ of~$v$ has a reference
  to~$c$ then $V$ contains a view $v'$ such that (a)~$v'.\fixed = v.\fixed$,
  (b)~$v'.\princ = c'$, and (c)~$v'$ contains $c$.
\end{enumerate}
\end{definition}
%
Informally, the condition says that we can find individual views that include
the references from $c$ to~$v$, and vice versa. 

\begin{improve}
In clause~(2), we could require accordance, requiring $v$ and $v'$ to agree on
any other components.  It's not clear if this is best. 
\end{improve}

In transition~(\ref{trans:getNext}), the state $\Node_y(n, n')$ is compatible
with the pre-view, assuming the set~$V$ of views contains: (1)~a view of the
form $v_c = (fixed(t, n_h, n_l);\linebreak[1] \Node_y(n, n'), \linebreak[1]
\Node_z(n', n''))$ for some~$z$ and~$n''$, to satisfy
clause~\ref{item:compatible-1}; and (2) a view of the form $v' = (fixed(t,
n_h, n_l); \Node(n_h, n), \linebreak[1] \Node_y(n, n'))$ to satisfy
clause~\ref{item:compatible-2}.

\begin{impNote}
This is checked in
  \texttt{Extendability.\linebreak[1]compatible\-With}, with
  \texttt{Extendability.isExtendable} checking the latter clause.
\end{impNote}


We show in Section~\ref{sec:views-correctness} that consistency
implies compatibility.  Our implementation uses the weaker definition of
compatibility; this means that we over-estimate the abstract transition
relation, so preserve correctness.  Our experience is that this approximation
does not lead to false positives.

In the transitions we have considered so far, the pre-view contains every
component that synchronises on the transition.  This won't always be true.  In
such a case, we extend the pre-view to add each compatible state of such a
component that can perform the relevant state.  For example, $initNode$
transitions can be captured by extending a view such as 
\[
(fixed(t, n_h, n_l); Enq_3^x(t, n_l), \Node_y(n_l, n')
\]
adding the node being initialised (which must necessarily be in the $\InitNode$
state).

\begin{equation}
\begin{alignc}
(fixed(t, n_h, n_l);   Enq_3^x(t, n_l), \Node_y(n_l, n'), \InitNode(n))
    \trans{initNode_x.t.n.null} \\
\qquad (fixed(t, n_h, n_l);
   Enq_4^x(t, n_l, n), \Node_y(n_l, n'), \Node_x(n, null)).
\end{alignc}
\label{trans:initNode}
\end{equation}
%% The above transition also illustrates that the post-state might be strictly
%% larger than the corresponding view of the principal component: the thread
%% loses the reference to~$n$ in the transition.  It is straightforward to remove
%% components that are no longer referenced in order to obtain the relevant view.

%% The transition~(\ref{trans:initNode}) produces a new view for
%% another component involved in the transition, here the view $(\Lock'(t),
%% Top(n); Node_x(n'', n), Node_y(n, n'))$ of~$n''$.  In this case, the node $n$
%% to which $n''$ acquires a reference was included in the transition, because
%% the thread~$t$ had a reference to it in the pre-state.  In all realistic
%% examples we are aware of, a similar fact is true: a secondary component
%% obtains a reference only to other components to which the primary component
%% previously had a reference.  Thus our implementation assumes this
%% condition.


The following definition summarises this subsection.
%
\begin{definition}
\label{def:active-process-transition}
Given a set $V$ of views, we build the active-process transitions as follows.
For each $v \in V$, we consider each view transition $v \trans{e} v'$ of~$v$.
We consider each identity $id$, not matching the identity of a component
of~$v$ and such that
%
\begin{itemize}
\item $e$ is in the alphabet of~$id$; or

\item $v.princ$ acquires a reference to~$id$ in the transition
\end{itemize}
%
For each such~$id$ (by assumption, there is at most one), we find all
component states~$c$ with identity~$id$ that are compatible with~$v$
(Definition~\ref{def:compatible}).  We form all pre-states $pre$ by extending
$v$ with each such component state~$c$.  We form corresponding post-states
$post$ by extending $v'$ with the corresponding post-states, i.e.\ each
state~$c'$ such that $c \trans{e} c'$ if $e$ is in the alphabet of~$id$; or
otherwise the same states~$c$.  Thus we form extended transitions $pre
\trans{e} post$ including all the relevant component states.  Finally, we
extract from $post$ the view~$v''$ of the principal component, to create an
abstract transition $v \trans{e} v''$.
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Induced transitions}

So far, we have considered only transitions that involved an active process
(either the principal or a fixed process). However, such a transition can
induce other abstract transitions.  For example the
transition~(\ref{trans:lock}) changes the state of a fixed process, and so
induces corresponding changes in other views; for example, it induces abstract
transitions concerning another thread or a node in its initial state:
%
\[
\begin{align}
(fixed(\_, n_h, n_l); Thread(t'))  \trans{lock.t} 
  (fixed(t, n_h, n_l); Thread(t')), \\
(fixed(\_, n_h, n_l); \InitNode(n))  \trans{lock.t} 
  (fixed(t, n_h, n_l); \InitNode(n)),
\end{align}
\]
%
for $t' \in ThreadID$ with $t' \ne t$, and for $n \in NodeID$.

\begin{definition}
\label{def:induced-transition}
Consider an extended transition~$pre \trans{e} post$, and a view $v \in V$
such that $v$ and $pre$ are accordant.  Then the transition \emph{induces} a
new transition $v \trans{} v'$ where:
\begin{enumerate}
\item $v'.\fixed = post.\fixed$.

\item If $v.\princ$ is in $pre$ then $v'.\princ$ is the corresponding
  component in~$post$; otherwise $v'.princ = v.princ$.

\item The secondary components of~$v'$ are the components referenced by
  $v'.princ$, either from $post$ if the component is part of the transition,
  or otherwise from~$v$.  (Note that all such components are included in
  either $post$ or~$v$, by clause~\ref{assump:secondary-cpts-new-refs} of
  Assumption~\ref{assump}.)
\end{enumerate}
\end{definition}

%%%%%

For example, the  transition~(\ref{trans:initNode}) induces a transition
\[
\begin{align}
(fixed(t, n_h, n_l); \InitNode(n)) \trans{} 
  (fixed(t, n_h, n_l); \Node_x(n, null)),
\end{align}
\]
where $n$ evolves as in (\ref{trans:initNode}).
%
As another example, consider the extended transition where an enqueueing
thread sets the next reference of the last node:
\[
\begin{align}
(fixed(t, n_h, n_l);  Enq_4(t, n_l, n), \Node_y(n_l, null), \Node_x(n, null)) 
 \trans{setNext.t.n_l.n} \\
\qquad (fixed(t, n_h, n_l);  Enq_5(t, n), \Node_y(n_l, n), \Node_x(n, null)).
\end{align}
\]
This induces the following transition on the view of~$n_l$:
\[
\begin{align}
(fixed(t, n_h, n_l);  \Node_y(n_l, null)) \trans{}  % setNext.t.n_l.n} \\
  (fixed(t, n_h, n_l);  \Node_y(n_l, n), \Node_x(n, null)).
\end{align}
\]

%%%%%

We note some optimisations concerning the use of
Definition~\ref{def:induced-transition}.  
%
\begin{opt}
\label{opt:avoid-induced}
A straightforward use of Definition~\ref{def:induced-transition} would
consider many different extended transitions $pre \trans{e} post$ and
views~$v$ to create new post-views.  However, it turns out that many of these
induced transitions create identical post-views.
%
\begin{itemize}
\item If $pre.\princ = v.\princ$ then the induced transition is identical to the
  original transition. % We therefore avoid recreating this transition.

\item Suppose $pre.\fixed = post.\fixed$ and $v$ contains no component that
  changes state in the transition.  Then the new view~$v'$ is identical
  to~$v$. 

\item Now suppose $pre.\fixed \ne post.\fixed$, but $v$ again contains no
  component that changes state in the transition.  Then the new view~$v'$ will
  be different from~$v$.  However, suppose we subsequently consider another
  extended transition $pre' \trans{} post'$ with $pre'.\fixed = pre.\fixed$
  and $post'.\fixed = post.\fixed$, and consider its effect on the same~$v$.
  Then this will induce a transition to the same post-view~$v'$.   
\end{itemize}

We identify such cases early, and avoid producing the duplicate post-views. 
\end{opt}

\begin{impNote}
The above optimisation is implemented in
\texttt{Unification.isSufficientUnif}.  
\end{impNote}

\begin{improve}
Can it be done earlier?  Also, it would seem better to store the relevant
information in the view.
\end{improve}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Correctness}
\label{sec:views-correctness}


The following definition summarises how we calculate the abstract transitions.

\begin{definition}
\label{def:abstract-transition}
Given a set $V$ of views, we build each active-process extended transition
$pre \trans{e} post$, and the corresponding abstract transitions $v \trans{e}
v'$, as in Definition~\ref{def:active-process-transition}.
%
We then also create every transition that $pre \trans{e} post$ induces on a
view in~$V$, as in Definition~\ref{def:induced-transition}. 
\end{definition}

We start by comparing the properties of compatibility and consistency
%
\begin{lemma}
\label{lem:consistent-implies-compatible}
Let $V$ be a set of views.
If a component state~$c$ is consistent with a view~$v \in V$, then
$c$ is compatible with~$v$. 
\end{lemma}
%
\begin{proof}
Suppose $c$ is consistent with~$v$.  Then there exists $s \in \gamma(V)$ such
that $v \uplus c \sqle s$.  Taking $v_c = view(s, c)$ satisfies
clause~\ref{item:compatible-1} of Definition~\ref{def:compatible}: note that
$v_c \sqle_\V s \in \gamma(V)$ so $v_c \in V$.  For each component $c'$ of~$v$
that has a reference to~$c$, taking $v' = view(s,c')$ satisfies
clause~\ref{item:compatible-2}: again $v' \in V$.
\end{proof}

The converse of the above lemma doesn't hold, informally because the views
required for the different constraints of Definition~\ref{def:compatible}
might come from different system states.  More concretely, consider a system
containing just the following system states.
%
\begin{eqnarray*}
s_0 & = &
   (\fixed; Th(t,n_1,n_2), N_A(n_1,n_3), N_B(n_2), N_X(n_3), N_D(n_4,n_3)), \\
s_1 & = &
  (\fixed; Th(t,n_1,n_2), N_X(n_1), N_B(n_2), N_C(n_3,n_2), N_D(n_4,n_1)),\\
s_2 & = & 
  (\fixed; Th(t,n_1,n_2), N_A(n_1,n_3), N_X(n_2), N_C(n_3,n_2), N_D(n_4,n_2)).
\end{eqnarray*}
%
Let $V = \alpha(\set{s_0,s_1,s_2})$ be all views of these states.  Let
\[
v = (\fixed; Th(t,n_1,n_2), N_A(n_1, n_3), N_B(n_2)).
\]
This is a view of the system, resulting from~$s_0$.  Let 
\[
c = N_C(n_3,n_2).
\]  
Then  $c$ is compatible with~$v$:
%
clause~\ref{item:compatible-1} of Definition~\ref{def:compatible} is satisfied
by $(\fixed; N_C(n_3,n_2), N_B(n_2))$, which is a view resulting
from~$s_1$;
%
and clause~\ref{item:compatible-2} is satisfied for $c' = N_A(n_1,n_3)$ by
$(\fixed; N_A(n_1, n_3), N_C(n_3,n_2))$, which is a view resulting
from~$s_2$. 
%%  And it is satisfied for $c' = N_D(n_4,n_1,n_3)$ by $(\fixed;
%% N_D(n_4,n_1,n_3), N_Y(n_1,n_3),N_C(n_3,n_2)


However $c$ is not consistent with~$v$.  Suppose we have \( v \uplus
c \sqle s \) for some $s \in \gamma(V)$.  Then $s$ is necessarily of the form
\[
\begin{align}
(\fixed, Th(t,n_1,n_2), N_A(n_1, n_3), N_B(n_2), N_C(n_3,n_2), c_4) \\
\qquad \mbox{where $c_4 = N_D(n_4,x)$ for some $x$.}
\end{align}
\]
But no value of~$x$ works: in each case, we have that $view(s, c_4) \nin
\gamma(V)$, since in no system state does $n_4$ have a reference to a
component in state~$N_A$, $N_B$ or~$N_C$.

%% : there is no system state
%% containing $v \uplus c$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{prop}
\label{lem:abstract-transitions-sound}
Let $V$ be a set of views.  Every abstract transition from~$V$ is generated by
the procedure in Definition~\ref{def:abstract-transition}.
\end{prop}

\begin{proof} 
Consider an abstract transition
\[
\gamma(V) \ni s \trans{e} s' \sqge_{\V} v'.
\]
We need to show that we generate $v'$ as part of the process described above.
Let $pId = v'.\princ.id$ be the identity of the principal of~$v'$, and suppose
that component has states $princ$ and $princ'$ in~$s$ and~$s'$, respectively
(so $v' = view(s', princ')$).  We perform a case analysis.
%
\begin{enumerate}
\item
First suppose $pId$ is the active component in the concrete transition
\( {s \trans{e} s'} \).
Let $v = view(princ, s)$.  
%
Suppose another component is necessary for the transition, as in
Definition~\ref{def:active-process-transition}, i.e.~either another component
synchronises on the transition, or the principal gains a reference, and
suppose that component has state~$c$ in~$s$.  Then $c$ is consistent
with~$v$, since $v \uplus c \sqle s \in \gamma(V)$.  Hence $c$ is compatible
with~$v$, by Lemma~\ref{lem:consistent-implies-compatible}.
%
Let $pre = v \uplus c$, or let $pre = v$ if no additional component is
necessary; and let $post$ be the corresponding states in~$s'$.  Then the
technique of Definition~\ref{def:active-process-transition} builds the
transition \( pre \trans{e} post \).  Finally, the principal's view of $post$
is extracted; this equals~$v'$ by construction, as required. 

%% \item 
%% Now suppose the transition involves an active fixed process, and suppose
%% $princ$ synchronises on the transition.  Let $v = view(princ, s)$.  This case
%% is then  identical to the previous case.

\item
Now suppose the transition $s \trans{e} s'$ has an active component other
than~$pId$.  Let $pre \trans{e} post$ be the corresponding extended
transition, built as in Definition~\ref{def:active-process-transition}.  Let
$v = view(princ, s)$.  Then necessarily $v$ and $pre$ are accordant, since
they are both substates of~$s$.  Then the transition $v \trans{} v'$ is
induced, as in Definition~\ref{def:induced-transition}.

\item\label{step:abs-trans-correct-3}
Finally suppose the transition $s \trans{e} s'$ has an active fixed process.
Consider an arbitrary corresponding view transition (i.e.~with an arbitrary
principal), and consider the corresponding extended transition $pre \trans{e}
post$.  This case is then identical to the previous case.
\end{enumerate}
\end{proof}


\begin{impNote}
The fact that point~3 covers all transitions with active fixed
  processes suggests that we could be more restrictive about generating such
  transitions in Definition~\ref{def:active-process-transition}.
\end{impNote}


\begin{opt}
Case~\ref{step:abs-trans-correct-3} above considered an \emph{arbitrary}
corresponding view transition.  All such view transitions will generate the
same abstract transition, so clearly, it would be enough to consider fewer, as
long as we include at least one.  In the case that the active fixed process
synchronises with a passive component~$c$, we consider just the view
transition with~$c$ as principal.  (In the case that the active fixed process
synchronises with no component, we consider all such view transitions; there
is potential for further optimisation here, but these cases seem rare.)
\end{opt}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \subsection{Implementation notes}

%% To support the above, we need to record the following about transitions.
%% %
%% \begin{itemize}
%% \item
%% Given a component state $cpt$ and an event~$a$, a function to return the set
%% of $cpt'$ such that $cpt \trans{a} cpt'$.

%% \item
%% Given a state $srvs$ of the servers and an event~$a$, a function to return the
%% set of~$srv'$ such that $srv \trans{a} srv'$.
%% \end{itemize}

%% We also need to store the following about $V$.
%% \begin{itemize}
%% \item
%% Given a concretization $conc \in \gamma(V)$ and a component state~$c$ for a
%% component identity not in $conc$, test whether $conc \uplus \set{c} \in
%% \gamma(V)$.  (For constructing the transitions of concretizations.)

%% \item (For item~\ref{case:view-principal-changes}.) Given a concretization
%%   $conc \in \gamma(V)$ and a component identity~$id$ not in $conc$, find all
%%   states~$c$ for~$id$ such that $conc \uplus \set{c} \in \gamma(V)$.  In
%%   nearly all cases, at least one process in $conc$ will hold the
%%   reference~$id$.  If a server holds such a reference, iterate over all
%%   relevant server views to find compatible states.  If a component holds such
%%   a reference, iterate over all views of that component to find all compatible
%%   states. 



%% Given a state $srvs$ of the servers, and states of some of the components
%% referenced by $srvs$, all compatible states of other such components.

%% \end{itemize}
