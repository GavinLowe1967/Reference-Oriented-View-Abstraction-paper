
\section{Choosing the views}

Say that a process state $c$ \emph{references} a component~$cpt$ if
$cpt.id \in c.\params$. 

Consider a system state $s = (\fixed, \cpt)$, and a particular component $cpt
\in \cpts$.  Let $\cpts' \subseteq \cpt$ be all components in $\cpt$ that are
referenced by $cpt$ (including $cpt$ itself).  We define the corresponding
view to be $(\fixed, \cpt')$.  Write this as $view(s, cpt)$.  Say that $cpt$
is the principal component of this view.  Given a view~$v$, we write
$v.\princ$ for its principal component.

Example.

In the running example, the initial views are of the form
\[
\begin{array}{ll}
(Lock, Top(null); Thread(t)) &  \mbox{for $t \in ThreadID$}, \\
(Lock, Top(null); InitNode(n)) & \mbox{for $n \in NodeID$},
\end{array}
\]

%% Given a state $s = (\fixed, \cpt)$, let $\cpt' \subseteq
%% \cpt$ be all components with identity referenced by some server in
%% $\fixed$.  We define a corresponding view to be $(\fixed, \cpt')$.
%% Write this as $srvView(s)$.

Let 
\begin{eqnarray*}
\V & = & 
  \set{view(s, cpt) | s \in \S, cpt \in s.\cpt}. %%  \union 
  %% \set{srvView(s) | s \in \S}.
\end{eqnarray*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Calculating abstract transitions}

The critical thing, then, is, given $V \subseteq \V$, to calculate
\begin{eqnarray*}
aPost(V) & = & \alpha(post(\gamma(V)))
\end{eqnarray*}
efficiently.  It's enough to consider new such views, i.e.~those not in~$V$.
In fact, we slightly over-estimate $aPost(V)$.

%% For the moment, let's consider only active components.  \framebox{Extend} to
%% active servers.

We are seeking to identify views~$v$ such that
\[
\gamma(V) \ni s \trans{a} s' \sqge_\V v
\]
for some $s$, $s'$, $a$.
%% We begin by describing how to capture the concrete transitions corresponding
%% to the abstract transitions; we then describe how to extract the new
%% views. 

Informally, our approach will be as follows.  We will start with a view $v \in
V$ whose principal component is an active component, and consider the
transitions of that active component.  In some cases we will need to expand
the view to include additional relevant components: either those components
that synchronise on the transition, or to which the principal component
obtains a reference.  We assume that there is at most one such new component.
%% We will call such an expanded view a \emph{concretization}.  
When we expand a
view in this way, we do so only in a way that is compatible with the set $V$
of views.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\textbf{Tactic:} Work with example of lock-based stack from the previous
paper.  Consider a few concrete transitions of this model, and how they are
reflected by abstract transitions.  Present the concretizations that the
algorithm considers.  Then show this is adequate.

Each abstract transition will be built from a \emph{view transition}, i.e.~a
transition formed by considering a single view in isolation, as captured by
the following definition.
%
\begin{definition}
We define a \emph{view transition} of view~$v$ to be a transition $v \trans{e}
v'$ such that
%
\begin{itemize}
\item Either $v$ has an active principal or an active fixed process with $e$
  in its alphabet;

\item $v'$ is the same as~$v$ except replacing every (fixed or component)
  process~$p$ that has $e$ in its alphabet with a process $p'$ such that $p
  \trans{e} p'$.  (Note that $v'$ might not be a view if the principal
  component gains or loses a reference as a result of the transition; we
  discuss this further below.)
\end{itemize}
\end{definition}

Consider a transition where a thread pushing~$x$ performs a $lock$ event.
This can be captured by the view transition
%
\begin{eqnarray}
(Lock, Top(null); Push^x_1(t)) & \trans{lock.t} & 
  (Lock'(t), Top(null); Push^x_2(t))
\label{trans:lock}
\end{eqnarray}
%
for $t \in ThreadID$.  

In this particular case, the view transition is also an abstract transition.
Each of the pre- and post-states in this transition is a view, with $t$ as the
principal component.  Further, the pre-view contains all components with
$lock.t$ in their alphabet, so in a concrete state, no other process would
synchronise on the transition.  Hence this abstract transition can be found by
looking just at the view transitions of the pre-view.
%%  processes in the former view.  We call
%% this an \emph{active-component transition}: the active component in the
%% transition is the principal component of the pre- and post-states.

The abstract transition in the previous paragraphs was fairly straightforward,
as all the relevant component states were in the initial view.  This might not
always be the case.  Consider a transition where a pushing thread reads a
value $n \ne null$ from $Top$.  This can be partially described by the
view transition
\begin{eqnarray*}
(Lock'(t), Top(n); Push_3^x(t)) & \trans{getTop.t.n} &
  (Lock'(t), Top(n); Push_4^x(t, n)).
\end{eqnarray*}
However, the post-state is not a view, as it does not contain the node~$n$
referenced by~$t$.  Instead, we need to extend both states to include this
node, giving transitions such as
%
\begin{equation}
\begin{alignc}
(Lock'(t), Top(n); Push_3^x(t), Node_y(n, n'))  \trans{getTop.t.n} \\
\qquad  (Lock'(t), Top(n); Push_4^x(t, n), Node_y(n, n')).
\end{alignc}
\label{trans:getTop}
\end{equation}
%
We call the above an \emph{extended transition}: we have extended the pre-view
(with~$t$ as the principal component) by adding the component for~$n$.  In the
interests of simplicity, we make the assumption that it is necessary to add at
most one such node, i.e.~the principal component obtains at most one new
reference in each transition.

We can generate such transitions by considering the view transitions; then
extending the pre-state to add a compatible state of a component to which the
principal component acquires a reference; and adding the corresponding state
of each such component to the post state (here the added component does not
synchronise on the transition so remains in the same state).  The following
definitions describe what we mean by \emph{compatible}.

\begin{definition}
Let $V$ be a set of views.
\begin{itemize}
\item An extended view~$v$ is \emph{strongly consistent} if there exists a
  state $s \in \gamma(V)$ such that $v \sqle s$. \framebox{Needed?}

\item A component state~$c$ is \emph{strongly compatible} with a view~$v \in
  V$ (with $c.\id$ disjoint from the identities in~$v$) if $v \uplus c$ is
  strongly consistent.
\end{itemize}
\end{definition}


The above condition is rather expensive to check, so we weaken it slightly. 
%
\begin{definition}
\label{def:compatible}
Let $V$ be a set of views.  A component state~$c$ is \emph{compatible} with a
view $v \in V$ if:
%
\begin{enumerate}
\item\label{item:compatible-1} $V$ contains a view $v_c$ such that
  (a)~$v_c.\fixed = v.\fixed$, (b)~$v_c.\princ = c$, and (c)~if $c$ has a
  reference to a component of~$v$, then $v$ and~$v_c$ agree on that component.

\item\label{item:compatible-2} If any component $c'$ of~$v$ has a reference
  to~$c$ then $V$ contains a view $v'$ such that (a)~$v'.\fixed = v.fixed$,
  (b)~$v'.\princ = c'$, and (c)~$v'$ contains $c$.
\end{enumerate}
\end{definition}

In transition~(\ref{trans:getTop}), the state $Node_y(n, n')$ is compatible
with the pre-view, assuming the set~$V$ of views contains a view of the form
$v_c = (Lock'(t), Top(n); Node_y(n, n'), Node_z(n', n''))$ for some~$z$
and~$n''$, to satisfy clause~\ref{item:compatible-1}
(clause~\ref{item:compatible-2} is satisfied vacuously).

\impNote{This is checked in
  \texttt{Extendability.\linebreak[1]compatible\-With}, with
  \texttt{Extendability.isExtendable} checking the latter clause.}

\begin{lemma}
If a component state~$c$ is strongly compatible with a view~$v$, then
$c$ is compatible with~$v$. 
\end{lemma}
%
\begin{proof}
Suppose $c$ is strongly compatible with~$v$.  Then there exists $s \in
\gamma(V)$ such that $v \uplus c \sqle s$.  Taking $v_c = view(s, c)$
satisfies clause~\ref{item:compatible-1} of Definition~\ref{def:compatible}.
For each component $c'$ of~$v$ that has a reference to~$c$, taking $v' =
view(s,c')$ satisfies clause~\ref{item:compatible-2}.
\end{proof}

The converse of the above lemma doesn't hold, informally because the views
required for the different constraints of Definition~\ref{def:compatible}
might come from different system states.  More concretely, consider a system
containing just the following system states.
%
\begin{eqnarray*}
s_0 & = &
   (\fixed; Thread(T,N_1,N_2), Node_A(N_1,N_3), Node_B(N_2), Node_X(N_3)), \\
s_1 & = &
  (\fixed; Thread(T,N_1,N_2), Node_Y(N_1,N_3), Node_B(N_2), Node_C(N_3,N_2)), \\
s_2 & = & 
  (\fixed; Thread(T,N_1,N_2), Node_A(N_1,N_3), Node_X(N_2), Node_C(N_3,N_2)).
\end{eqnarray*}
%
Let 
\[
v = (\fixed, Thread(T, N_1, N_2), Node_A(N_1, N_3), Node_B(N_2)).
\]
This is a view of the system, resulting from~$s_0$.  Let 
\[
c = Node_C(N_3,N_2).
\]  
Then $c$ is not strongly compatible with~$v$: there is no system state
containing $v \uplus c$.  However, $c$ is compatible with~$v$.
%
Clause~\ref{item:compatible-1} of Definition~\ref{def:compatible} is satisfied
by $(\fixed; Node_C(N_3,N_2), Node_B(N_2))$, which is a view resulting
from~$s_1$.
%
And clause~\ref{item:compatible-2} is satisfied by $(\fixed; Node_A(N_1, N_3),
Node_C(N_3,N_2))$, which is a view resulting from~$s_2$.

Our implementation uses the weaker definition of compatibility, rather than
strong compatibility.  This means that we over-estimate the abstract
transition relation, so preserve correctness.  Our experience is that this
approximation does not lead to false positives. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% %
%% \begin{definition}
%% Given a set of views $V$, we say that two substates~$c$ and~$c'$ are
%% \emph{compatible} if (1)~$c.\fixed = c'.\fixed$; and (2)~for every
%% identity~$id$ such that $c.\cpt$ and $c'.\cpt$ both have a component with
%% identity~$id$, the corresponding component states are equal.
%% %% ; and (3) the combined substate $(c.\fixed,
%% %% c.\cpt \union c'.\cpt)$ is consistent with~$V$.
%% \end{definition}
%% %
%% Note that the conditions mean that the combined state  $(c.\fixed,
%% c.\cpt \union c'.\cpt)$ makes sense.
%% %

%% Note that there's a bit of an abstraction here.  We don't check that the whole
%% of the combined state $(c.\fixed, c.\cpt \union c'.\cpt)$ is compatible
%% with~$V$: there might be other views of it that aren't in~$V$.

%% ***** Is this right?  Consider a getNext transition. 


%% \begin{definition}
%% Given a set of views $V$, we say that a component state~$cpt$ is
%% \emph{compatible} with a view~$v$ if there is a view $v' \in V$ that is
%% compatible with~$v$ and for which $cpt$ is the principal component state.
%% %
%% In this case, we define the extension of $v$ with $cpt$ to be $(v.\fixed,
%% v.\cpt \union \set{cpt})$, i.e.~we add~$cpt$ to~$v$.
%% \end{definition}
%

In the transitions we have considered so far, the pre-view contains every
component that synchronises on the transition.  This won't always be true.  In
such a case, we extend the pre-view to add each compatible state of such a
component that can perform the relevant state.  For example, $initNode$
transitions can be captured by extending the view obtained in
transition~(\ref{trans:getTop}), adding the node being initialised (which must
necessarily be in the $InitNode$ state).
\begin{equation}
\begin{alignc}
  (Lock'(t), Top(n); Push_4^x(t, n), Node_y(n, n'), InitNode(n'')) 
    \trans{initNode_x.t.n''.n} \\
\qquad  (Lock'(t), Top(n); Push_5(t, n''), Node_y(n, n'), Node_x(n'', n))
\end{alignc}
\label{trans:initNode}
\end{equation}
The above transition also illustrates that the post-concretization might be
strictly larger than the corresponding view of the principal component: the
thread loses the reference to~$n$ in the transition.  It is straightforward to
remove components that are no longer referenced in order to obtain the
relevant view.  

The transition~(\ref{trans:initNode}) produces a new view for
another component involved in the transition, here the view $(Lock'(t),
Top(n); Node_x(n'', n), Node_y(n, n'))$ of~$n''$.  In this case, the node $n$
to which $n''$ acquires a reference was included in the transition, because
the thread~$t$ had a reference to it in the pre-state.  In all realistic
examples we are aware of, a similar fact is true: a secondary component
obtains a reference only to other components to which the primary component
previously had a reference.  Thus our implementation assumes this condition.


%% However, if this is not the case, it is necessary
%% to extend the pre-state by adding each compatible state of the relevant
%% component.  (\textbf{note} not in prototype?).

%% Another example.  A thread sets the \SCALA{next} reference of a node~$n$ to
%% point to another node~$n'$.  This can be captured by the following
%% transition (where we elide the fixed components). 
%% \[
%% \begin{align}
%% (\ldots; Thread(t, n, n'), Node_x(n, null), Node_y(n', n'')) 
%%   \trans{setNext.t.n.n'} \\
%% \qquad (\ldots; Thread'(t, n, n'), Node_x(n, n'), Node_y(n', n'')).
%% \end{align}
%% \]
%% Note that this transition produces a new view where the node~$n$ is the
%% principal component and has a reference to~$n'$.

So far, we have considered only transitions that produce a view such that the
primary component synchronised on the transition.  However, such a transition
can induce other abstract transitions.  For example the
transition~(\ref{trans:lock}) changes the state of a fixed process, and so
induces corresponding changes in other views; for example, it induces abstract
transitions concerning another thread or a node in its initial state:
%
\begin{eqnarray*}
(Lock, Top(null); Thread(t')) & \trans{lock.t} & 
  (Lock'(t), Top(null); Thread(t')), \\
(Lock, Top(null); InitNode(n)) & \trans{lock.t} & 
  (Lock'(t), Top(null); InitNode(n)),
\end{eqnarray*}
%
for $t' \in ThreadID$ with $t' \ne t$, and for $n \in NodeID$.




\begin{definition}
Consider an abstract transition~$pre \trans{e} post$, and a view $v$ such that
$v$ and $pre$ are accordant, but $pre$ does not contain the principal
component of~$v$ \framebox{?}.  Then the abstract transition \emph{induces} a
new transition $v \trans{e} v'$ where $v'.\fixed = post.\fixed$, and
$v'.\cpts$ is the same as $v.\cpts$ except each component that changes state
in the transition is replaced by the corresponding component of~$post$.
\end{definition}

As another example, consider a different datatype (e.g.~a queue) where a
thread~$t$ sets the \SCALA{next} reference of a node~$n$ to point to another
node~$n'$.  This can be captured by a transition such as the following.
\[
\begin{align}
(\fixed; Thread(t, n, n'), Node_x(n, null), Node_y(n', n'')) 
  \trans{setNext.t.n.n'} \\
\qquad (\fixed'; Thread'(t, n, n'), Node_x(n, n'), Node_y(n', n'')).
\end{align}
\]
If some other node (or thread) can have a reference to the node~$n$, this can
induce new transitions, such as the following (assuming the pre-state is
in~$V$). 
\[
\begin{align}
(\fixed; Node_z(n''', n), Node_x(n, null))  \trans{setNext.t.n.n'} \\
\qquad  (\fixed'; Node_z(n''', n), Node_x(n, n')).
\end{align}
\]


\begin{definition}
Given a set $V$ of views, we build the abstract transitions as follows.  For
each $v \in V$, we consider each transition $v \trans{e} v'$ that is possible
for $v.princ$ and any other process in~$v$ that has~$e$ in its alphabet.  We
consider each identity $id$, not matching the identity of a component of~$v$
and such that
%
\begin{itemize}
\item $e$ is in the alphabet of~$id$; or

\item $v.princ$ acquires a reference to~$id$ in the transition
\end{itemize}
%
For each such~$id$, we find all component states~$c$ with identity~$id$ that
are compatible with~$v$.  We form all pre-states $pre$ by extending $v$ with
each such component state~$c$.  We form corresponding post-states $post$ by
extending $v'$ with the corresponding post-states, i.e.\ each state~$c'$ such
that $c \trans{e} c'$ if $e$ is in the alphabet of~$id$; or otherwise the same
states~$c$.  Thus we form extended transitions $pre \trans{e} post$ including
all the relevant component states.

\end{definition}







active/passive principals, and also servers.  This is probably just an
optimisation. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Implementation notes}

To support the above, we need to record the following about transitions.
%
\begin{itemize}
\item
Given a component state $cpt$ and an event~$a$, a function to return the set
of $cpt'$ such that $cpt \trans{a} cpt'$.

\item
Given a state $srvs$ of the servers and an event~$a$, a function to return the
set of~$srv'$ such that $srv \trans{a} srv'$.
\end{itemize}

We also need to store the following about $V$.
\begin{itemize}
\item
Given a concretization $conc \in \gamma(V)$ and a component state~$c$ for a
component identity not in $conc$, test whether $conc \uplus \set{c} \in
\gamma(V)$.  (For constructing the transitions of concretizations.)

\item (For item~\ref{case:view-principal-changes}.) Given a concretization
  $conc \in \gamma(V)$ and a component identity~$id$ not in $conc$, find all
  states~$c$ for~$id$ such that $conc \uplus \set{c} \in \gamma(V)$.  In
  nearly all cases, at least one process in $conc$ will hold the
  reference~$id$.  If a server holds such a reference, iterate over all
  relevant server views to find compatible states.  If a component holds such
  a reference, iterate over all views of that component to find all compatible
  states. 



Given a state $srvs$ of the servers, and states of some of the components
referenced by $srvs$, all compatible states of other such components.

\end{itemize}
